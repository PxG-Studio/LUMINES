(self.webpackChunklumines_wissil=self.webpackChunklumines_wissil||[]).push([[1263],{"./node_modules/@babel/runtime/helpers/esm/toArray.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>_toArray});var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"),_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/iterableToArray.js"),_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"),_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");function _toArray(r){return(0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__.A)(r)||(0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__.A)(r)||(0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.A)(r)||(0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__.A)()}},"./node_modules/esbuild-wasm/lib/browser.js":(module,__unused_webpack_exports,__webpack_require__)=>{module=__webpack_require__.nmd(module);var Buffer=__webpack_require__("./node_modules/buffer/index.js").hp,console=__webpack_require__("./node_modules/console-browserify/index.js");(module=>{"use strict";var mod,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__async=(__this,__arguments,generator)=>new Promise((resolve,reject)=>{var fulfilled=value=>{try{step(generator.next(value))}catch(e){reject(e)}},rejected=value=>{try{step(generator.throw(value))}catch(e){reject(e)}},step=x=>x.done?resolve(x.value):Promise.resolve(x.value).then(fulfilled,rejected);step((generator=generator.apply(__this,__arguments)).next())}),browser_exports={};function encodePacket(packet){let visit=value=>{if(null===value)bb.write8(0);else if("boolean"==typeof value)bb.write8(1),bb.write8(+value);else if("number"==typeof value)bb.write8(2),bb.write32(0|value);else if("string"==typeof value)bb.write8(3),bb.write(encodeUTF8(value));else if(value instanceof Uint8Array)bb.write8(4),bb.write(value);else if(value instanceof Array){bb.write8(5),bb.write32(value.length);for(let item of value)visit(item)}else{let keys=Object.keys(value);bb.write8(6),bb.write32(keys.length);for(let key of keys)bb.write(encodeUTF8(key)),visit(value[key])}},bb=new ByteBuffer;return bb.write32(0),bb.write32(packet.id<<1|+!packet.isRequest),visit(packet.value),writeUInt32LE(bb.buf,bb.len-4,0),bb.buf.subarray(0,bb.len)}((target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})})(browser_exports,{analyzeMetafile:()=>analyzeMetafile,analyzeMetafileSync:()=>analyzeMetafileSync,build:()=>build,buildSync:()=>buildSync,context:()=>context,default:()=>browser_default,formatMessages:()=>formatMessages,formatMessagesSync:()=>formatMessagesSync,initialize:()=>initialize,stop:()=>stop,transform:()=>transform,transformSync:()=>transformSync,version:()=>version}),module.exports=(mod=browser_exports,((to,from,except,desc)=>{if(from&&"object"==typeof from||"function"==typeof from)for(let key of __getOwnPropNames(from))__hasOwnProp.call(to,key)||key===except||__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to})(__defProp({},"__esModule",{value:!0}),mod));var encodeUTF8,decodeUTF8,encodeInvariant,ByteBuffer=class{constructor(buf=new Uint8Array(1024)){this.buf=buf,this.len=0,this.ptr=0}_write(delta){if(this.len+delta>this.buf.length){let clone=new Uint8Array(2*(this.len+delta));clone.set(this.buf),this.buf=clone}return this.len+=delta,this.len-delta}write8(value){let offset=this._write(1);this.buf[offset]=value}write32(value){let offset=this._write(4);writeUInt32LE(this.buf,value,offset)}write(bytes){let offset=this._write(4+bytes.length);writeUInt32LE(this.buf,bytes.length,offset),this.buf.set(bytes,offset+4)}_read(delta){if(this.ptr+delta>this.buf.length)throw new Error("Invalid packet");return this.ptr+=delta,this.ptr-delta}read8(){return this.buf[this._read(1)]}read32(){return readUInt32LE(this.buf,this._read(4))}read(){let length=this.read32(),bytes=new Uint8Array(length),ptr=this._read(bytes.length);return bytes.set(this.buf.subarray(ptr,ptr+length)),bytes}};if("undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder){let encoder=new TextEncoder,decoder=new TextDecoder;encodeUTF8=text=>encoder.encode(text),decodeUTF8=bytes=>decoder.decode(bytes),encodeInvariant='new TextEncoder().encode("")'}else{if(void 0===Buffer)throw new Error("No UTF-8 codec found");encodeUTF8=text=>Buffer.from(text),decodeUTF8=bytes=>{let{buffer,byteOffset,byteLength}=bytes;return Buffer.from(buffer,byteOffset,byteLength).toString()},encodeInvariant='Buffer.from("")'}if(!(encodeUTF8("")instanceof Uint8Array))throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false\n\nThis indicates that your JavaScript environment is broken. You cannot use\nesbuild in this environment because esbuild relies on this invariant. This\nis not a problem with esbuild. You need to fix your environment instead.\n`);function readUInt32LE(buffer,offset){return buffer[offset++]|buffer[offset++]<<8|buffer[offset++]<<16|buffer[offset++]<<24}function writeUInt32LE(buffer,value,offset){buffer[offset++]=value,buffer[offset++]=value>>8,buffer[offset++]=value>>16,buffer[offset++]=value>>24}var quote=JSON.stringify;function validateTarget(target){if(validateStringValue(target,"target"),target.indexOf(",")>=0)throw new Error(`Invalid target: ${target}`);return target}var canBeAnything=()=>null,mustBeBoolean=value=>"boolean"==typeof value?null:"a boolean",mustBeString=value=>"string"==typeof value?null:"a string",mustBeRegExp=value=>value instanceof RegExp?null:"a RegExp object",mustBeInteger=value=>"number"==typeof value&&value===(0|value)?null:"an integer",mustBeFunction=value=>"function"==typeof value?null:"a function",mustBeArray=value=>Array.isArray(value)?null:"an array",mustBeObject=value=>"object"!=typeof value||null===value||Array.isArray(value)?"an object":null,mustBeEntryPoints=value=>"object"==typeof value&&null!==value?null:"an array or an object",mustBeWebAssemblyModule=value=>value instanceof WebAssembly.Module?null:"a WebAssembly.Module",mustBeObjectOrNull=value=>"object"!=typeof value||Array.isArray(value)?"an object or null":null,mustBeStringOrBoolean=value=>"string"==typeof value||"boolean"==typeof value?null:"a string or a boolean",mustBeStringOrObject=value=>"string"==typeof value||"object"==typeof value&&null!==value&&!Array.isArray(value)?null:"a string or an object",mustBeStringOrArray=value=>"string"==typeof value||Array.isArray(value)?null:"a string or an array",mustBeStringOrUint8Array=value=>"string"==typeof value||value instanceof Uint8Array?null:"a string or a Uint8Array",mustBeStringOrURL=value=>"string"==typeof value||value instanceof URL?null:"a string or a URL";function getFlag(object,keys,key,mustBeFn){let value=object[key];if(keys[key+""]=!0,void 0===value)return;let mustBe=mustBeFn(value);if(null!==mustBe)throw new Error(`${quote(key)} must be ${mustBe}`);return value}function checkForInvalidFlags(object,keys,where){for(let key in object)if(!(key in keys))throw new Error(`Invalid option ${where}: ${quote(key)}`)}function validateMangleCache(mangleCache){let validated;if(void 0!==mangleCache){validated=Object.create(null);for(let key in mangleCache){let value=mangleCache[key];if("string"!=typeof value&&!1!==value)throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);validated[key]=value}}return validated}function pushLogFlags(flags,options,keys,isTTY,logLevelDefault){let color=getFlag(options,keys,"color",mustBeBoolean),logLevel=getFlag(options,keys,"logLevel",mustBeString),logLimit=getFlag(options,keys,"logLimit",mustBeInteger);void 0!==color?flags.push(`--color=${color}`):isTTY&&flags.push("--color=true"),flags.push(`--log-level=${logLevel||logLevelDefault}`),flags.push(`--log-limit=${logLimit||0}`)}function validateStringValue(value,what,key){if("string"!=typeof value)throw new Error(`Expected value for ${what}${void 0!==key?" "+quote(key):""} to be a string, got ${typeof value} instead`);return value}function pushCommonFlags(flags,options,keys){let legalComments=getFlag(options,keys,"legalComments",mustBeString),sourceRoot=getFlag(options,keys,"sourceRoot",mustBeString),sourcesContent=getFlag(options,keys,"sourcesContent",mustBeBoolean),target=getFlag(options,keys,"target",mustBeStringOrArray),format=getFlag(options,keys,"format",mustBeString),globalName=getFlag(options,keys,"globalName",mustBeString),mangleProps=getFlag(options,keys,"mangleProps",mustBeRegExp),reserveProps=getFlag(options,keys,"reserveProps",mustBeRegExp),mangleQuoted=getFlag(options,keys,"mangleQuoted",mustBeBoolean),minify=getFlag(options,keys,"minify",mustBeBoolean),minifySyntax=getFlag(options,keys,"minifySyntax",mustBeBoolean),minifyWhitespace=getFlag(options,keys,"minifyWhitespace",mustBeBoolean),minifyIdentifiers=getFlag(options,keys,"minifyIdentifiers",mustBeBoolean),lineLimit=getFlag(options,keys,"lineLimit",mustBeInteger),drop=getFlag(options,keys,"drop",mustBeArray),dropLabels=getFlag(options,keys,"dropLabels",mustBeArray),charset=getFlag(options,keys,"charset",mustBeString),treeShaking=getFlag(options,keys,"treeShaking",mustBeBoolean),ignoreAnnotations=getFlag(options,keys,"ignoreAnnotations",mustBeBoolean),jsx=getFlag(options,keys,"jsx",mustBeString),jsxFactory=getFlag(options,keys,"jsxFactory",mustBeString),jsxFragment=getFlag(options,keys,"jsxFragment",mustBeString),jsxImportSource=getFlag(options,keys,"jsxImportSource",mustBeString),jsxDev=getFlag(options,keys,"jsxDev",mustBeBoolean),jsxSideEffects=getFlag(options,keys,"jsxSideEffects",mustBeBoolean),define=getFlag(options,keys,"define",mustBeObject),logOverride=getFlag(options,keys,"logOverride",mustBeObject),supported=getFlag(options,keys,"supported",mustBeObject),pure=getFlag(options,keys,"pure",mustBeArray),keepNames=getFlag(options,keys,"keepNames",mustBeBoolean),platform=getFlag(options,keys,"platform",mustBeString),tsconfigRaw=getFlag(options,keys,"tsconfigRaw",mustBeStringOrObject);if(legalComments&&flags.push(`--legal-comments=${legalComments}`),void 0!==sourceRoot&&flags.push(`--source-root=${sourceRoot}`),void 0!==sourcesContent&&flags.push(`--sources-content=${sourcesContent}`),target&&(Array.isArray(target)?flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`):flags.push(`--target=${validateTarget(target)}`)),format&&flags.push(`--format=${format}`),globalName&&flags.push(`--global-name=${globalName}`),platform&&flags.push(`--platform=${platform}`),tsconfigRaw&&flags.push(`--tsconfig-raw=${"string"==typeof tsconfigRaw?tsconfigRaw:JSON.stringify(tsconfigRaw)}`),minify&&flags.push("--minify"),minifySyntax&&flags.push("--minify-syntax"),minifyWhitespace&&flags.push("--minify-whitespace"),minifyIdentifiers&&flags.push("--minify-identifiers"),lineLimit&&flags.push(`--line-limit=${lineLimit}`),charset&&flags.push(`--charset=${charset}`),void 0!==treeShaking&&flags.push(`--tree-shaking=${treeShaking}`),ignoreAnnotations&&flags.push("--ignore-annotations"),drop)for(let what of drop)flags.push(`--drop:${validateStringValue(what,"drop")}`);if(dropLabels&&flags.push(`--drop-labels=${Array.from(dropLabels).map(what=>validateStringValue(what,"dropLabels")).join(",")}`),mangleProps&&flags.push(`--mangle-props=${mangleProps.source}`),reserveProps&&flags.push(`--reserve-props=${reserveProps.source}`),void 0!==mangleQuoted&&flags.push(`--mangle-quoted=${mangleQuoted}`),jsx&&flags.push(`--jsx=${jsx}`),jsxFactory&&flags.push(`--jsx-factory=${jsxFactory}`),jsxFragment&&flags.push(`--jsx-fragment=${jsxFragment}`),jsxImportSource&&flags.push(`--jsx-import-source=${jsxImportSource}`),jsxDev&&flags.push("--jsx-dev"),jsxSideEffects&&flags.push("--jsx-side-effects"),define)for(let key in define){if(key.indexOf("=")>=0)throw new Error(`Invalid define: ${key}`);flags.push(`--define:${key}=${validateStringValue(define[key],"define",key)}`)}if(logOverride)for(let key in logOverride){if(key.indexOf("=")>=0)throw new Error(`Invalid log override: ${key}`);flags.push(`--log-override:${key}=${validateStringValue(logOverride[key],"log override",key)}`)}if(supported)for(let key in supported){if(key.indexOf("=")>=0)throw new Error(`Invalid supported: ${key}`);const value=supported[key];if("boolean"!=typeof value)throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);flags.push(`--supported:${key}=${value}`)}if(pure)for(let fn of pure)flags.push(`--pure:${validateStringValue(fn,"pure")}`);keepNames&&flags.push("--keep-names")}function createChannel(streamIn){const requestCallbacksByKey={},closeData={didClose:!1,reason:""};let responseCallbacks={},nextRequestID=0,nextBuildKey=0,stdout=new Uint8Array(16384),stdoutUsed=0,sendRequest=(refs,value,callback)=>{if(closeData.didClose)return callback("The service is no longer running"+closeData.reason,null);let id=nextRequestID++;responseCallbacks[id]=(error,response)=>{try{callback(error,response)}finally{refs&&refs.unref()}},refs&&refs.ref(),streamIn.writeToStdin(encodePacket({id,isRequest:!0,value}))},sendResponse=(id,value)=>{if(closeData.didClose)throw new Error("The service is no longer running"+closeData.reason);streamIn.writeToStdin(encodePacket({id,isRequest:!1,value}))},handleRequest=(id,request)=>__async(this,null,function*(){try{if("ping"===request.command)return void sendResponse(id,{});if("number"==typeof request.key){const requestCallbacks=requestCallbacksByKey[request.key];if(!requestCallbacks)return;const callback=requestCallbacks[request.command];if(callback)return void(yield callback(id,request))}throw new Error("Invalid command: "+request.command)}catch(e){const errors=[extractErrorMessageV8(e,streamIn,null,void 0,"")];try{sendResponse(id,{errors})}catch(e2){}}}),isFirstPacket=!0,handleIncomingPacket=bytes=>{if(isFirstPacket){isFirstPacket=!1;let binaryVersion=String.fromCharCode(...bytes);if("0.19.12"!==binaryVersion)throw new Error(`Cannot start service: Host version "0.19.12" does not match binary version ${quote(binaryVersion)}`);return}let packet=function decodePacket(bytes){let visit=()=>{switch(bb.read8()){case 0:return null;case 1:return!!bb.read8();case 2:return bb.read32();case 3:return decodeUTF8(bb.read());case 4:return bb.read();case 5:{let count=bb.read32(),value2=[];for(let i=0;i<count;i++)value2.push(visit());return value2}case 6:{let count=bb.read32(),value2={};for(let i=0;i<count;i++)value2[decodeUTF8(bb.read())]=visit();return value2}default:throw new Error("Invalid packet")}},bb=new ByteBuffer(bytes),id=bb.read32(),isRequest=!(1&id);id>>>=1;let value=visit();if(bb.ptr!==bytes.length)throw new Error("Invalid packet");return{id,isRequest,value}}(bytes);if(packet.isRequest)handleRequest(packet.id,packet.value);else{let callback=responseCallbacks[packet.id];delete responseCallbacks[packet.id],packet.value.error?callback(packet.value.error,{}):callback(null,packet.value)}};return{readFromStdout:chunk=>{let limit=stdoutUsed+chunk.length;if(limit>stdout.length){let swap=new Uint8Array(2*limit);swap.set(stdout),stdout=swap}stdout.set(chunk,stdoutUsed),stdoutUsed+=chunk.length;let offset=0;for(;offset+4<=stdoutUsed;){let length=readUInt32LE(stdout,offset);if(offset+4+length>stdoutUsed)break;offset+=4,handleIncomingPacket(stdout.subarray(offset,offset+length)),offset+=length}offset>0&&(stdout.copyWithin(0,offset,stdoutUsed),stdoutUsed-=offset)},afterClose:error=>{closeData.didClose=!0,error&&(closeData.reason=": "+(error.message||error));const text="The service was stopped"+closeData.reason;for(let id in responseCallbacks)responseCallbacks[id](text,null);responseCallbacks={}},service:{buildOrContext:({callName,refs,options,isTTY,defaultWD,callback})=>{let refCount=0;const buildKey=nextBuildKey++,requestCallbacks={},buildRefs={ref(){1===++refCount&&refs&&refs.ref()},unref(){0===--refCount&&(delete requestCallbacksByKey[buildKey],refs&&refs.unref())}};requestCallbacksByKey[buildKey]=requestCallbacks,buildRefs.ref(),function buildOrContextImpl(callName,buildKey,sendRequest,sendResponse,refs,streamIn,requestCallbacks,options,isTTY,defaultWD,callback){const details=createObjectStash(),isContext="context"===callName,handleError=(e,pluginName)=>{const flags=[];try{pushLogFlags(flags,options,{},isTTY,"warning")}catch(e2){}const message=extractErrorMessageV8(e,streamIn,details,void 0,pluginName);sendRequest(refs,{command:"error",flags,error:message},()=>{message.detail=details.load(message.detail),callback(failureErrorWithLog(isContext?"Context failed":"Build failed",[message],[]),null)})};let plugins;if("object"==typeof options){const value=options.plugins;if(void 0!==value){if(!Array.isArray(value))return handleError(new Error('"plugins" must be an array'),"");plugins=value}}if(plugins&&plugins.length>0)return streamIn.isSync?handleError(new Error("Cannot use plugins in synchronous API calls"),""):void handlePlugins(buildKey,sendRequest,sendResponse,refs,streamIn,requestCallbacks,options,plugins,details).then(result=>{if(!result.ok)return handleError(result.error,result.pluginName);try{buildOrContextContinue(result.requestPlugins,result.runOnEndCallbacks,result.scheduleOnDisposeCallbacks)}catch(e){handleError(e,"")}},e=>handleError(e,""));try{buildOrContextContinue(null,(result,done)=>done([],[]),()=>{})}catch(e){handleError(e,"")}function buildOrContextContinue(requestPlugins,runOnEndCallbacks,scheduleOnDisposeCallbacks){const writeDefault=streamIn.hasFS,{entries,flags,write,stdinContents,stdinResolveDir,absWorkingDir,nodePaths,mangleCache}=function flagsForBuildOptions(callName,options,isTTY,logLevelDefault,writeDefault){var _a;let flags=[],entries=[],keys=Object.create(null),stdinContents=null,stdinResolveDir=null;pushLogFlags(flags,options,keys,isTTY,logLevelDefault),pushCommonFlags(flags,options,keys);let sourcemap=getFlag(options,keys,"sourcemap",mustBeStringOrBoolean),bundle=getFlag(options,keys,"bundle",mustBeBoolean),splitting=getFlag(options,keys,"splitting",mustBeBoolean),preserveSymlinks=getFlag(options,keys,"preserveSymlinks",mustBeBoolean),metafile=getFlag(options,keys,"metafile",mustBeBoolean),outfile=getFlag(options,keys,"outfile",mustBeString),outdir=getFlag(options,keys,"outdir",mustBeString),outbase=getFlag(options,keys,"outbase",mustBeString),tsconfig=getFlag(options,keys,"tsconfig",mustBeString),resolveExtensions=getFlag(options,keys,"resolveExtensions",mustBeArray),nodePathsInput=getFlag(options,keys,"nodePaths",mustBeArray),mainFields=getFlag(options,keys,"mainFields",mustBeArray),conditions=getFlag(options,keys,"conditions",mustBeArray),external=getFlag(options,keys,"external",mustBeArray),packages=getFlag(options,keys,"packages",mustBeString),alias=getFlag(options,keys,"alias",mustBeObject),loader=getFlag(options,keys,"loader",mustBeObject),outExtension=getFlag(options,keys,"outExtension",mustBeObject),publicPath=getFlag(options,keys,"publicPath",mustBeString),entryNames=getFlag(options,keys,"entryNames",mustBeString),chunkNames=getFlag(options,keys,"chunkNames",mustBeString),assetNames=getFlag(options,keys,"assetNames",mustBeString),inject=getFlag(options,keys,"inject",mustBeArray),banner=getFlag(options,keys,"banner",mustBeObject),footer=getFlag(options,keys,"footer",mustBeObject),entryPoints=getFlag(options,keys,"entryPoints",mustBeEntryPoints),absWorkingDir=getFlag(options,keys,"absWorkingDir",mustBeString),stdin=getFlag(options,keys,"stdin",mustBeObject),write=null!=(_a=getFlag(options,keys,"write",mustBeBoolean))?_a:writeDefault,allowOverwrite=getFlag(options,keys,"allowOverwrite",mustBeBoolean),mangleCache=getFlag(options,keys,"mangleCache",mustBeObject);if(keys.plugins=!0,checkForInvalidFlags(options,keys,`in ${callName}() call`),sourcemap&&flags.push("--sourcemap"+(!0===sourcemap?"":`=${sourcemap}`)),bundle&&flags.push("--bundle"),allowOverwrite&&flags.push("--allow-overwrite"),splitting&&flags.push("--splitting"),preserveSymlinks&&flags.push("--preserve-symlinks"),metafile&&flags.push("--metafile"),outfile&&flags.push(`--outfile=${outfile}`),outdir&&flags.push(`--outdir=${outdir}`),outbase&&flags.push(`--outbase=${outbase}`),tsconfig&&flags.push(`--tsconfig=${tsconfig}`),packages&&flags.push(`--packages=${packages}`),resolveExtensions){let values=[];for(let value of resolveExtensions){if(validateStringValue(value,"resolve extension"),value.indexOf(",")>=0)throw new Error(`Invalid resolve extension: ${value}`);values.push(value)}flags.push(`--resolve-extensions=${values.join(",")}`)}if(publicPath&&flags.push(`--public-path=${publicPath}`),entryNames&&flags.push(`--entry-names=${entryNames}`),chunkNames&&flags.push(`--chunk-names=${chunkNames}`),assetNames&&flags.push(`--asset-names=${assetNames}`),mainFields){let values=[];for(let value of mainFields){if(validateStringValue(value,"main field"),value.indexOf(",")>=0)throw new Error(`Invalid main field: ${value}`);values.push(value)}flags.push(`--main-fields=${values.join(",")}`)}if(conditions){let values=[];for(let value of conditions){if(validateStringValue(value,"condition"),value.indexOf(",")>=0)throw new Error(`Invalid condition: ${value}`);values.push(value)}flags.push(`--conditions=${values.join(",")}`)}if(external)for(let name of external)flags.push(`--external:${validateStringValue(name,"external")}`);if(alias)for(let old in alias){if(old.indexOf("=")>=0)throw new Error(`Invalid package name in alias: ${old}`);flags.push(`--alias:${old}=${validateStringValue(alias[old],"alias",old)}`)}if(banner)for(let type in banner){if(type.indexOf("=")>=0)throw new Error(`Invalid banner file type: ${type}`);flags.push(`--banner:${type}=${validateStringValue(banner[type],"banner",type)}`)}if(footer)for(let type in footer){if(type.indexOf("=")>=0)throw new Error(`Invalid footer file type: ${type}`);flags.push(`--footer:${type}=${validateStringValue(footer[type],"footer",type)}`)}if(inject)for(let path of inject)flags.push(`--inject:${validateStringValue(path,"inject")}`);if(loader)for(let ext in loader){if(ext.indexOf("=")>=0)throw new Error(`Invalid loader extension: ${ext}`);flags.push(`--loader:${ext}=${validateStringValue(loader[ext],"loader",ext)}`)}if(outExtension)for(let ext in outExtension){if(ext.indexOf("=")>=0)throw new Error(`Invalid out extension: ${ext}`);flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext],"out extension",ext)}`)}if(entryPoints)if(Array.isArray(entryPoints))for(let i=0,n=entryPoints.length;i<n;i++){let entryPoint=entryPoints[i];if("object"==typeof entryPoint&&null!==entryPoint){let entryPointKeys=Object.create(null),input=getFlag(entryPoint,entryPointKeys,"in",mustBeString),output=getFlag(entryPoint,entryPointKeys,"out",mustBeString);if(checkForInvalidFlags(entryPoint,entryPointKeys,"in entry point at index "+i),void 0===input)throw new Error('Missing property "in" for entry point at index '+i);if(void 0===output)throw new Error('Missing property "out" for entry point at index '+i);entries.push([output,input])}else entries.push(["",validateStringValue(entryPoint,"entry point at index "+i)])}else for(let key in entryPoints)entries.push([key,validateStringValue(entryPoints[key],"entry point",key)]);if(stdin){let stdinKeys=Object.create(null),contents=getFlag(stdin,stdinKeys,"contents",mustBeStringOrUint8Array),resolveDir=getFlag(stdin,stdinKeys,"resolveDir",mustBeString),sourcefile=getFlag(stdin,stdinKeys,"sourcefile",mustBeString),loader2=getFlag(stdin,stdinKeys,"loader",mustBeString);checkForInvalidFlags(stdin,stdinKeys,'in "stdin" object'),sourcefile&&flags.push(`--sourcefile=${sourcefile}`),loader2&&flags.push(`--loader=${loader2}`),resolveDir&&(stdinResolveDir=resolveDir),"string"==typeof contents?stdinContents=encodeUTF8(contents):contents instanceof Uint8Array&&(stdinContents=contents)}let nodePaths=[];if(nodePathsInput)for(let value of nodePathsInput)value+="",nodePaths.push(value);return{entries,flags,write,stdinContents,stdinResolveDir,absWorkingDir,nodePaths,mangleCache:validateMangleCache(mangleCache)}}(callName,options,isTTY,"warning",writeDefault);if(write&&!streamIn.hasFS)throw new Error('The "write" option is unavailable in this environment');const request={command:"build",key:buildKey,entries,flags,write,stdinContents,stdinResolveDir,absWorkingDir:absWorkingDir||defaultWD,nodePaths,context:isContext};requestPlugins&&(request.plugins=requestPlugins),mangleCache&&(request.mangleCache=mangleCache);const buildResponseToResult=(response,callback2)=>{const result={errors:replaceDetailsInMessages(response.errors,details),warnings:replaceDetailsInMessages(response.warnings,details),outputFiles:void 0,metafile:void 0,mangleCache:void 0},originalErrors=result.errors.slice(),originalWarnings=result.warnings.slice();response.outputFiles&&(result.outputFiles=response.outputFiles.map(convertOutputFiles)),response.metafile&&(result.metafile=JSON.parse(response.metafile)),response.mangleCache&&(result.mangleCache=response.mangleCache),void 0!==response.writeToStdout&&console.log(decodeUTF8(response.writeToStdout).replace(/\n$/,"")),runOnEndCallbacks(result,(onEndErrors,onEndWarnings)=>{if(originalErrors.length>0||onEndErrors.length>0){const error=failureErrorWithLog("Build failed",originalErrors.concat(onEndErrors),originalWarnings.concat(onEndWarnings));return callback2(error,null,onEndErrors,onEndWarnings)}callback2(null,result,onEndErrors,onEndWarnings)})};let latestResultPromise,provideLatestResult;isContext&&(requestCallbacks["on-end"]=(id,request2)=>new Promise(resolve=>{buildResponseToResult(request2,(err,result,onEndErrors,onEndWarnings)=>{const response={errors:onEndErrors,warnings:onEndWarnings};provideLatestResult&&provideLatestResult(err,result),latestResultPromise=void 0,provideLatestResult=void 0,sendResponse(id,response),resolve()})})),sendRequest(refs,request,(error,response)=>{if(error)return callback(new Error(error),null);if(!isContext)return buildResponseToResult(response,(err,res)=>(scheduleOnDisposeCallbacks(),callback(err,res)));if(response.errors.length>0)return callback(failureErrorWithLog("Context failed",response.errors,response.warnings),null);let didDispose=!1;const result={rebuild:()=>(latestResultPromise||(latestResultPromise=new Promise((resolve,reject)=>{let settlePromise;provideLatestResult=(err,result2)=>{settlePromise||(settlePromise=()=>err?reject(err):resolve(result2))};const triggerAnotherBuild=()=>{sendRequest(refs,{command:"rebuild",key:buildKey},(error2,response2)=>{error2?reject(new Error(error2)):settlePromise?settlePromise():triggerAnotherBuild()})};triggerAnotherBuild()})),latestResultPromise),watch:(options2={})=>new Promise((resolve,reject)=>{if(!streamIn.hasFS)throw new Error('Cannot use the "watch" API in this environment');checkForInvalidFlags(options2,{},"in watch() call");sendRequest(refs,{command:"watch",key:buildKey},error2=>{error2?reject(new Error(error2)):resolve(void 0)})}),serve:(options2={})=>new Promise((resolve,reject)=>{if(!streamIn.hasFS)throw new Error('Cannot use the "serve" API in this environment');const keys={},port=getFlag(options2,keys,"port",mustBeInteger),host=getFlag(options2,keys,"host",mustBeString),servedir=getFlag(options2,keys,"servedir",mustBeString),keyfile=getFlag(options2,keys,"keyfile",mustBeString),certfile=getFlag(options2,keys,"certfile",mustBeString),fallback=getFlag(options2,keys,"fallback",mustBeString),onRequest=getFlag(options2,keys,"onRequest",mustBeFunction);checkForInvalidFlags(options2,keys,"in serve() call");const request2={command:"serve",key:buildKey,onRequest:!!onRequest};void 0!==port&&(request2.port=port),void 0!==host&&(request2.host=host),void 0!==servedir&&(request2.servedir=servedir),void 0!==keyfile&&(request2.keyfile=keyfile),void 0!==certfile&&(request2.certfile=certfile),void 0!==fallback&&(request2.fallback=fallback),sendRequest(refs,request2,(error2,response2)=>{if(error2)return reject(new Error(error2));onRequest&&(requestCallbacks["serve-request"]=(id,request3)=>{onRequest(request3.args),sendResponse(id,{})}),resolve(response2)})}),cancel:()=>new Promise(resolve=>{if(didDispose)return resolve();sendRequest(refs,{command:"cancel",key:buildKey},()=>{resolve()})}),dispose:()=>new Promise(resolve=>{if(didDispose)return resolve();didDispose=!0;sendRequest(refs,{command:"dispose",key:buildKey},()=>{resolve(),scheduleOnDisposeCallbacks(),refs.unref()})})};refs.ref(),callback(null,result)})}}(callName,buildKey,sendRequest,sendResponse,buildRefs,streamIn,requestCallbacks,options,isTTY,defaultWD,(err,res)=>{try{callback(err,res)}finally{buildRefs.unref()}})},transform:({callName,refs,input,options,isTTY,fs,callback})=>{const details=createObjectStash();let start=inputPath=>{try{if("string"!=typeof input&&!(input instanceof Uint8Array))throw new Error('The input to "transform" must be a string or a Uint8Array');let{flags,mangleCache}=function flagsForTransformOptions(callName,options,isTTY,logLevelDefault){let flags=[],keys=Object.create(null);pushLogFlags(flags,options,keys,isTTY,logLevelDefault),pushCommonFlags(flags,options,keys);let sourcemap=getFlag(options,keys,"sourcemap",mustBeStringOrBoolean),sourcefile=getFlag(options,keys,"sourcefile",mustBeString),loader=getFlag(options,keys,"loader",mustBeString),banner=getFlag(options,keys,"banner",mustBeString),footer=getFlag(options,keys,"footer",mustBeString),mangleCache=getFlag(options,keys,"mangleCache",mustBeObject);return checkForInvalidFlags(options,keys,`in ${callName}() call`),sourcemap&&flags.push(`--sourcemap=${!0===sourcemap?"external":sourcemap}`),sourcefile&&flags.push(`--sourcefile=${sourcefile}`),loader&&flags.push(`--loader=${loader}`),banner&&flags.push(`--banner=${banner}`),footer&&flags.push(`--footer=${footer}`),{flags,mangleCache:validateMangleCache(mangleCache)}}(callName,options,isTTY,"silent"),request={command:"transform",flags,inputFS:null!==inputPath,input:null!==inputPath?encodeUTF8(inputPath):"string"==typeof input?encodeUTF8(input):input};mangleCache&&(request.mangleCache=mangleCache),sendRequest(refs,request,(error,response)=>{if(error)return callback(new Error(error),null);let errors=replaceDetailsInMessages(response.errors,details),warnings=replaceDetailsInMessages(response.warnings,details),outstanding=1,next=()=>{if(0===--outstanding){let result={warnings,code:response.code,map:response.map,mangleCache:void 0,legalComments:void 0};"legalComments"in response&&(result.legalComments=null==response?void 0:response.legalComments),response.mangleCache&&(result.mangleCache=null==response?void 0:response.mangleCache),callback(null,result)}};if(errors.length>0)return callback(failureErrorWithLog("Transform failed",errors,warnings),null);response.codeFS&&(outstanding++,fs.readFile(response.code,(err,contents)=>{null!==err?callback(err,null):(response.code=contents,next())})),response.mapFS&&(outstanding++,fs.readFile(response.map,(err,contents)=>{null!==err?callback(err,null):(response.map=contents,next())})),next()})}catch(e){let flags=[];try{pushLogFlags(flags,options,{},isTTY,"silent")}catch(e2){}const error=extractErrorMessageV8(e,streamIn,details,void 0,"");sendRequest(refs,{command:"error",flags,error},()=>{error.detail=details.load(error.detail),callback(failureErrorWithLog("Transform failed",[error],[]),null)})}};if(("string"==typeof input||input instanceof Uint8Array)&&input.length>1048576){let next=start;start=()=>fs.writeFile(input,next)}start(null)},formatMessages:({callName,refs,messages,options,callback})=>{if(!options)throw new Error(`Missing second argument in ${callName}() call`);let keys={},kind=getFlag(options,keys,"kind",mustBeString),color=getFlag(options,keys,"color",mustBeBoolean),terminalWidth=getFlag(options,keys,"terminalWidth",mustBeInteger);if(checkForInvalidFlags(options,keys,`in ${callName}() call`),void 0===kind)throw new Error(`Missing "kind" in ${callName}() call`);if("error"!==kind&&"warning"!==kind)throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);let request={command:"format-msgs",messages:sanitizeMessages(messages,"messages",null,"",terminalWidth),isWarning:"warning"===kind};void 0!==color&&(request.color=color),void 0!==terminalWidth&&(request.terminalWidth=terminalWidth),sendRequest(refs,request,(error,response)=>{if(error)return callback(new Error(error),null);callback(null,response.messages)})},analyzeMetafile:({callName,refs,metafile,options,callback})=>{void 0===options&&(options={});let keys={},color=getFlag(options,keys,"color",mustBeBoolean),verbose=getFlag(options,keys,"verbose",mustBeBoolean);checkForInvalidFlags(options,keys,`in ${callName}() call`);let request={command:"analyze-metafile",metafile};void 0!==color&&(request.color=color),void 0!==verbose&&(request.verbose=verbose),sendRequest(refs,request,(error,response)=>{if(error)return callback(new Error(error),null);callback(null,response.result)})}}}}var handlePlugins=(buildKey,sendRequest,sendResponse,refs,streamIn,requestCallbacks,initialOptions,plugins,details)=>__async(void 0,null,function*(){let onStartCallbacks=[],onEndCallbacks=[],onResolveCallbacks={},onLoadCallbacks={},onDisposeCallbacks=[],nextCallbackID=0,i=0,requestPlugins=[],isSetupDone=!1;plugins=[...plugins];for(let item of plugins){let keys={};if("object"!=typeof item)throw new Error(`Plugin at index ${i} must be an object`);const name=getFlag(item,keys,"name",mustBeString);if("string"!=typeof name||""===name)throw new Error(`Plugin at index ${i} is missing a name`);try{let setup=getFlag(item,keys,"setup",mustBeFunction);if("function"!=typeof setup)throw new Error("Plugin is missing a setup function");checkForInvalidFlags(item,keys,`on plugin ${quote(name)}`);let plugin={name,onStart:!1,onEnd:!1,onResolve:[],onLoad:[]};i++;let promise=setup({initialOptions,resolve:(path,options={})=>{if(!isSetupDone)throw new Error('Cannot call "resolve" before plugin setup has completed');if("string"!=typeof path)throw new Error("The path to resolve must be a string");let keys2=Object.create(null),pluginName=getFlag(options,keys2,"pluginName",mustBeString),importer=getFlag(options,keys2,"importer",mustBeString),namespace=getFlag(options,keys2,"namespace",mustBeString),resolveDir=getFlag(options,keys2,"resolveDir",mustBeString),kind=getFlag(options,keys2,"kind",mustBeString),pluginData=getFlag(options,keys2,"pluginData",canBeAnything);return checkForInvalidFlags(options,keys2,"in resolve() call"),new Promise((resolve2,reject)=>{const request={command:"resolve",path,key:buildKey,pluginName:name};if(null!=pluginName&&(request.pluginName=pluginName),null!=importer&&(request.importer=importer),null!=namespace&&(request.namespace=namespace),null!=resolveDir&&(request.resolveDir=resolveDir),null==kind)throw new Error('Must specify "kind" when calling "resolve"');request.kind=kind,null!=pluginData&&(request.pluginData=details.store(pluginData)),sendRequest(refs,request,(error,response)=>{null!==error?reject(new Error(error)):resolve2({errors:replaceDetailsInMessages(response.errors,details),warnings:replaceDetailsInMessages(response.warnings,details),path:response.path,external:response.external,sideEffects:response.sideEffects,namespace:response.namespace,suffix:response.suffix,pluginData:details.load(response.pluginData)})})})},onStart(callback){let registeredNote=extractCallerV8(new Error('This error came from the "onStart" callback registered here:'),streamIn,"onStart");onStartCallbacks.push({name,callback,note:registeredNote}),plugin.onStart=!0},onEnd(callback){let registeredNote=extractCallerV8(new Error('This error came from the "onEnd" callback registered here:'),streamIn,"onEnd");onEndCallbacks.push({name,callback,note:registeredNote}),plugin.onEnd=!0},onResolve(options,callback){let registeredNote=extractCallerV8(new Error('This error came from the "onResolve" callback registered here:'),streamIn,"onResolve"),keys2={},filter=getFlag(options,keys2,"filter",mustBeRegExp),namespace=getFlag(options,keys2,"namespace",mustBeString);if(checkForInvalidFlags(options,keys2,`in onResolve() call for plugin ${quote(name)}`),null==filter)throw new Error("onResolve() call is missing a filter");let id=nextCallbackID++;onResolveCallbacks[id]={name,callback,note:registeredNote},plugin.onResolve.push({id,filter:filter.source,namespace:namespace||""})},onLoad(options,callback){let registeredNote=extractCallerV8(new Error('This error came from the "onLoad" callback registered here:'),streamIn,"onLoad"),keys2={},filter=getFlag(options,keys2,"filter",mustBeRegExp),namespace=getFlag(options,keys2,"namespace",mustBeString);if(checkForInvalidFlags(options,keys2,`in onLoad() call for plugin ${quote(name)}`),null==filter)throw new Error("onLoad() call is missing a filter");let id=nextCallbackID++;onLoadCallbacks[id]={name,callback,note:registeredNote},plugin.onLoad.push({id,filter:filter.source,namespace:namespace||""})},onDispose(callback){onDisposeCallbacks.push(callback)},esbuild:streamIn.esbuild});promise&&(yield promise),requestPlugins.push(plugin)}catch(e){return{ok:!1,error:e,pluginName:name}}}requestCallbacks["on-start"]=(id,request)=>__async(void 0,null,function*(){let response={errors:[],warnings:[]};yield Promise.all(onStartCallbacks.map(_0=>__async(void 0,[_0],function*({name,callback,note}){try{let result=yield callback();if(null!=result){if("object"!=typeof result)throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);let keys={},errors=getFlag(result,keys,"errors",mustBeArray),warnings=getFlag(result,keys,"warnings",mustBeArray);checkForInvalidFlags(result,keys,`from onStart() callback in plugin ${quote(name)}`),null!=errors&&response.errors.push(...sanitizeMessages(errors,"errors",details,name,void 0)),null!=warnings&&response.warnings.push(...sanitizeMessages(warnings,"warnings",details,name,void 0))}}catch(e){response.errors.push(extractErrorMessageV8(e,streamIn,details,note&&note(),name))}}))),sendResponse(id,response)}),requestCallbacks["on-resolve"]=(id,request)=>__async(void 0,null,function*(){let callback,note,response={},name="";for(let id2 of request.ids)try{({name,callback,note}=onResolveCallbacks[id2]);let result=yield callback({path:request.path,importer:request.importer,namespace:request.namespace,resolveDir:request.resolveDir,kind:request.kind,pluginData:details.load(request.pluginData)});if(null!=result){if("object"!=typeof result)throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);let keys={},pluginName=getFlag(result,keys,"pluginName",mustBeString),path=getFlag(result,keys,"path",mustBeString),namespace=getFlag(result,keys,"namespace",mustBeString),suffix=getFlag(result,keys,"suffix",mustBeString),external=getFlag(result,keys,"external",mustBeBoolean),sideEffects=getFlag(result,keys,"sideEffects",mustBeBoolean),pluginData=getFlag(result,keys,"pluginData",canBeAnything),errors=getFlag(result,keys,"errors",mustBeArray),warnings=getFlag(result,keys,"warnings",mustBeArray),watchFiles=getFlag(result,keys,"watchFiles",mustBeArray),watchDirs=getFlag(result,keys,"watchDirs",mustBeArray);checkForInvalidFlags(result,keys,`from onResolve() callback in plugin ${quote(name)}`),response.id=id2,null!=pluginName&&(response.pluginName=pluginName),null!=path&&(response.path=path),null!=namespace&&(response.namespace=namespace),null!=suffix&&(response.suffix=suffix),null!=external&&(response.external=external),null!=sideEffects&&(response.sideEffects=sideEffects),null!=pluginData&&(response.pluginData=details.store(pluginData)),null!=errors&&(response.errors=sanitizeMessages(errors,"errors",details,name,void 0)),null!=warnings&&(response.warnings=sanitizeMessages(warnings,"warnings",details,name,void 0)),null!=watchFiles&&(response.watchFiles=sanitizeStringArray(watchFiles,"watchFiles")),null!=watchDirs&&(response.watchDirs=sanitizeStringArray(watchDirs,"watchDirs"));break}}catch(e){response={id:id2,errors:[extractErrorMessageV8(e,streamIn,details,note&&note(),name)]};break}sendResponse(id,response)}),requestCallbacks["on-load"]=(id,request)=>__async(void 0,null,function*(){let callback,note,response={},name="";for(let id2 of request.ids)try{({name,callback,note}=onLoadCallbacks[id2]);let result=yield callback({path:request.path,namespace:request.namespace,suffix:request.suffix,pluginData:details.load(request.pluginData),with:request.with});if(null!=result){if("object"!=typeof result)throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);let keys={},pluginName=getFlag(result,keys,"pluginName",mustBeString),contents=getFlag(result,keys,"contents",mustBeStringOrUint8Array),resolveDir=getFlag(result,keys,"resolveDir",mustBeString),pluginData=getFlag(result,keys,"pluginData",canBeAnything),loader=getFlag(result,keys,"loader",mustBeString),errors=getFlag(result,keys,"errors",mustBeArray),warnings=getFlag(result,keys,"warnings",mustBeArray),watchFiles=getFlag(result,keys,"watchFiles",mustBeArray),watchDirs=getFlag(result,keys,"watchDirs",mustBeArray);checkForInvalidFlags(result,keys,`from onLoad() callback in plugin ${quote(name)}`),response.id=id2,null!=pluginName&&(response.pluginName=pluginName),contents instanceof Uint8Array?response.contents=contents:null!=contents&&(response.contents=encodeUTF8(contents)),null!=resolveDir&&(response.resolveDir=resolveDir),null!=pluginData&&(response.pluginData=details.store(pluginData)),null!=loader&&(response.loader=loader),null!=errors&&(response.errors=sanitizeMessages(errors,"errors",details,name,void 0)),null!=warnings&&(response.warnings=sanitizeMessages(warnings,"warnings",details,name,void 0)),null!=watchFiles&&(response.watchFiles=sanitizeStringArray(watchFiles,"watchFiles")),null!=watchDirs&&(response.watchDirs=sanitizeStringArray(watchDirs,"watchDirs"));break}}catch(e){response={id:id2,errors:[extractErrorMessageV8(e,streamIn,details,note&&note(),name)]};break}sendResponse(id,response)});let runOnEndCallbacks=(result,done)=>done([],[]);onEndCallbacks.length>0&&(runOnEndCallbacks=(result,done)=>{__async(void 0,null,function*(){const onEndErrors=[],onEndWarnings=[];for(const{name,callback,note}of onEndCallbacks){let newErrors,newWarnings;try{const value=yield callback(result);if(null!=value){if("object"!=typeof value)throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);let keys={},errors=getFlag(value,keys,"errors",mustBeArray),warnings=getFlag(value,keys,"warnings",mustBeArray);checkForInvalidFlags(value,keys,`from onEnd() callback in plugin ${quote(name)}`),null!=errors&&(newErrors=sanitizeMessages(errors,"errors",details,name,void 0)),null!=warnings&&(newWarnings=sanitizeMessages(warnings,"warnings",details,name,void 0))}}catch(e){newErrors=[extractErrorMessageV8(e,streamIn,details,note&&note(),name)]}if(newErrors){onEndErrors.push(...newErrors);try{result.errors.push(...newErrors)}catch(e){}}if(newWarnings){onEndWarnings.push(...newWarnings);try{result.warnings.push(...newWarnings)}catch(e){}}}done(onEndErrors,onEndWarnings)})});return isSetupDone=!0,{ok:!0,requestPlugins,runOnEndCallbacks,scheduleOnDisposeCallbacks:()=>{for(const cb of onDisposeCallbacks)setTimeout(()=>cb(),0)}}});function createObjectStash(){const map=new Map;let nextID=0;return{load:id=>map.get(id),store(value){if(void 0===value)return-1;const id=nextID++;return map.set(id,value),id}}}function extractCallerV8(e,streamIn,ident){let note,tried=!1;return()=>{if(tried)return note;tried=!0;try{let lines=(e.stack+"").split("\n");lines.splice(1,1);let location2=parseStackLinesV8(streamIn,lines,ident);if(location2)return note={text:e.message,location:location2},note}catch(e2){}}}function extractErrorMessageV8(e,streamIn,stash,note,pluginName){let text="Internal error",location2=null;try{text=(e&&e.message||e)+""}catch(e2){}try{location2=parseStackLinesV8(streamIn,(e.stack+"").split("\n"),"")}catch(e2){}return{id:"",pluginName,text,location:location2,notes:note?[note]:[],detail:stash?stash.store(e):-1}}function parseStackLinesV8(streamIn,lines,ident){let at="    at ";if(streamIn.readFileSync&&!lines[0].startsWith(at)&&lines[1].startsWith(at))for(let i=1;i<lines.length;i++){let line=lines[i];if(line.startsWith(at))for(line=line.slice(7);;){let match=/^(?:new |async )?\S+ \((.*)\)$/.exec(line);if(match)line=match[1];else{if(match=/^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line),!match){if(match=/^(\S+):(\d+):(\d+)$/.exec(line),match){let contents;try{contents=streamIn.readFileSync(match[1],"utf8")}catch(e){break}let lineText=contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2]-1]||"",column=+match[3]-1,length=lineText.slice(column,column+ident.length)===ident?ident.length:0;return{file:match[1],namespace:"file",line:+match[2],column:encodeUTF8(lineText.slice(0,column)).length,length:encodeUTF8(lineText.slice(column,column+length)).length,lineText:lineText+"\n"+lines.slice(1).join("\n"),suggestion:""}}break}line=match[1]}}}return null}function failureErrorWithLog(text,errors,warnings){text+=errors.length<1?"":` with ${errors.length} error${errors.length<2?"":"s"}:`+errors.slice(0,6).map((e,i)=>{if(5===i)return"\n...";if(!e.location)return`\nerror: ${e.text}`;let{file,line,column}=e.location;return`\n${file}:${line}:${column}: ERROR: ${e.pluginName?`[plugin: ${e.pluginName}] `:""}${e.text}`}).join("");let error=new Error(text);for(const[key,value]of[["errors",errors],["warnings",warnings]])Object.defineProperty(error,key,{configurable:!0,enumerable:!0,get:()=>value,set:value2=>Object.defineProperty(error,key,{configurable:!0,enumerable:!0,value:value2})});return error}function replaceDetailsInMessages(messages,stash){for(const message of messages)message.detail=stash.load(message.detail);return messages}function sanitizeLocation(location2,where,terminalWidth){if(null==location2)return null;let keys={},file=getFlag(location2,keys,"file",mustBeString),namespace=getFlag(location2,keys,"namespace",mustBeString),line=getFlag(location2,keys,"line",mustBeInteger),column=getFlag(location2,keys,"column",mustBeInteger),length=getFlag(location2,keys,"length",mustBeInteger),lineText=getFlag(location2,keys,"lineText",mustBeString),suggestion=getFlag(location2,keys,"suggestion",mustBeString);if(checkForInvalidFlags(location2,keys,where),lineText){const relevantASCII=lineText.slice(0,(column&&column>0?column:0)+(length&&length>0?length:0)+(terminalWidth&&terminalWidth>0?terminalWidth:80));/[\x7F-\uFFFF]/.test(relevantASCII)||/\n/.test(lineText)||(lineText=relevantASCII)}return{file:file||"",namespace:namespace||"",line:line||0,column:column||0,length:length||0,lineText:lineText||"",suggestion:suggestion||""}}function sanitizeMessages(messages,property,stash,fallbackPluginName,terminalWidth){let messagesClone=[],index=0;for(const message of messages){let keys={},id=getFlag(message,keys,"id",mustBeString),pluginName=getFlag(message,keys,"pluginName",mustBeString),text=getFlag(message,keys,"text",mustBeString),location2=getFlag(message,keys,"location",mustBeObjectOrNull),notes=getFlag(message,keys,"notes",mustBeArray),detail=getFlag(message,keys,"detail",canBeAnything),where=`in element ${index} of "${property}"`;checkForInvalidFlags(message,keys,where);let notesClone=[];if(notes)for(const note of notes){let noteKeys={},noteText=getFlag(note,noteKeys,"text",mustBeString),noteLocation=getFlag(note,noteKeys,"location",mustBeObjectOrNull);checkForInvalidFlags(note,noteKeys,where),notesClone.push({text:noteText||"",location:sanitizeLocation(noteLocation,where,terminalWidth)})}messagesClone.push({id:id||"",pluginName:pluginName||fallbackPluginName,text:text||"",location:sanitizeLocation(location2,where,terminalWidth),notes:notesClone,detail:stash?stash.store(detail):-1}),index++}return messagesClone}function sanitizeStringArray(values,property){const result=[];for(const value of values){if("string"!=typeof value)throw new Error(`${quote(property)} must be an array of strings`);result.push(value)}return result}function convertOutputFiles({path,contents,hash}){let text=null;return{path,contents,hash,get text(){const binary=this.contents;return null!==text&&binary===contents||(contents=binary,text=decodeUTF8(binary)),text}}}var initializePromise,stopService,longLivedService,version="0.19.12",build=options=>ensureServiceIsRunning().build(options),context=options=>ensureServiceIsRunning().context(options),transform=(input,options)=>ensureServiceIsRunning().transform(input,options),formatMessages=(messages,options)=>ensureServiceIsRunning().formatMessages(messages,options),analyzeMetafile=(metafile,options)=>ensureServiceIsRunning().analyzeMetafile(metafile,options),buildSync=()=>{throw new Error('The "buildSync" API only works in node')},transformSync=()=>{throw new Error('The "transformSync" API only works in node')},formatMessagesSync=()=>{throw new Error('The "formatMessagesSync" API only works in node')},analyzeMetafileSync=()=>{throw new Error('The "analyzeMetafileSync" API only works in node')},stop=()=>{stopService&&stopService()},ensureServiceIsRunning=()=>{if(longLivedService)return longLivedService;if(initializePromise)throw new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this');throw new Error('You need to call "initialize" before calling this')},initialize=options=>{options=function validateInitializeOptions(options){let keys=Object.create(null),wasmURL=getFlag(options,keys,"wasmURL",mustBeStringOrURL),wasmModule=getFlag(options,keys,"wasmModule",mustBeWebAssemblyModule),worker=getFlag(options,keys,"worker",mustBeBoolean);return checkForInvalidFlags(options,keys,"in initialize() call"),{wasmURL,wasmModule,worker}}(options||{});let wasmURL=options.wasmURL,wasmModule=options.wasmModule,useWorker=!1!==options.worker;if(!wasmURL&&!wasmModule)throw new Error('Must provide either the "wasmURL" option or the "wasmModule" option');if(initializePromise)throw new Error('Cannot call "initialize" more than once');return(initializePromise=startRunningService(wasmURL||"",wasmModule,useWorker)).catch(()=>{initializePromise=void 0}),initializePromise},startRunningService=(wasmURL,wasmModule,useWorker)=>__async(void 0,null,function*(){let worker,firstMessageResolve,firstMessageReject;if(useWorker){let blob=new Blob(['onmessage=((postMessage) => {\n      // Copyright 2018 The Go Authors. All rights reserved.\n      // Use of this source code is governed by a BSD-style\n      // license that can be found in the LICENSE file.\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve, reject) => {\n          var fulfilled = (value) => {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value) => {\n            try {\n              step(generator.throw(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      let onmessage;\n      let globalThis = {};\n      for (let o = self; o; o = Object.getPrototypeOf(o))\n        for (let k of Object.getOwnPropertyNames(o))\n          if (!(k in globalThis))\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\n      "use strict";\n      (() => {\n        const enosys = () => {\n          const err = new Error("not implemented");\n          err.code = "ENOSYS";\n          return err;\n        };\n        if (!globalThis.fs) {\n          let outputBuf = "";\n          globalThis.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\n            // unused\n            writeSync(fd, buf) {\n              outputBuf += decoder.decode(buf);\n              const nl = outputBuf.lastIndexOf("\\n");\n              if (nl != -1) {\n                console.log(outputBuf.substring(0, nl));\n                outputBuf = outputBuf.substring(nl + 1);\n              }\n              return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n              if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n              }\n              const n = this.writeSync(fd, buf);\n              callback(null, n);\n            },\n            chmod(path, mode, callback) {\n              callback(enosys());\n            },\n            chown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            close(fd, callback) {\n              callback(enosys());\n            },\n            fchmod(fd, mode, callback) {\n              callback(enosys());\n            },\n            fchown(fd, uid, gid, callback) {\n              callback(enosys());\n            },\n            fstat(fd, callback) {\n              callback(enosys());\n            },\n            fsync(fd, callback) {\n              callback(null);\n            },\n            ftruncate(fd, length, callback) {\n              callback(enosys());\n            },\n            lchown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            link(path, link, callback) {\n              callback(enosys());\n            },\n            lstat(path, callback) {\n              callback(enosys());\n            },\n            mkdir(path, perm, callback) {\n              callback(enosys());\n            },\n            open(path, flags, mode, callback) {\n              callback(enosys());\n            },\n            read(fd, buffer, offset, length, position, callback) {\n              callback(enosys());\n            },\n            readdir(path, callback) {\n              callback(enosys());\n            },\n            readlink(path, callback) {\n              callback(enosys());\n            },\n            rename(from, to, callback) {\n              callback(enosys());\n            },\n            rmdir(path, callback) {\n              callback(enosys());\n            },\n            stat(path, callback) {\n              callback(enosys());\n            },\n            symlink(path, link, callback) {\n              callback(enosys());\n            },\n            truncate(path, length, callback) {\n              callback(enosys());\n            },\n            unlink(path, callback) {\n              callback(enosys());\n            },\n            utimes(path, atime, mtime, callback) {\n              callback(enosys());\n            }\n          };\n        }\n        if (!globalThis.process) {\n          globalThis.process = {\n            getuid() {\n              return -1;\n            },\n            getgid() {\n              return -1;\n            },\n            geteuid() {\n              return -1;\n            },\n            getegid() {\n              return -1;\n            },\n            getgroups() {\n              throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            umask() {\n              throw enosys();\n            },\n            cwd() {\n              throw enosys();\n            },\n            chdir() {\n              throw enosys();\n            }\n          };\n        }\n        if (!globalThis.crypto) {\n          throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");\n        }\n        if (!globalThis.performance) {\n          throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");\n        }\n        if (!globalThis.TextEncoder) {\n          throw new Error("globalThis.TextEncoder is not available, polyfill required");\n        }\n        if (!globalThis.TextDecoder) {\n          throw new Error("globalThis.TextDecoder is not available, polyfill required");\n        }\n        const encoder = new TextEncoder("utf-8");\n        const decoder = new TextDecoder("utf-8");\n        globalThis.Go = class {\n          constructor() {\n            this.argv = ["js"];\n            this.env = {};\n            this.exit = (code) => {\n              if (code !== 0) {\n                console.warn("exit code:", code);\n              }\n            };\n            this._exitPromise = new Promise((resolve) => {\n              this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\n            this._nextCallbackTimeoutID = 1;\n            const setInt64 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            const getInt64 = (addr) => {\n              const low = this.mem.getUint32(addr + 0, true);\n              const high = this.mem.getInt32(addr + 4, true);\n              return low + high * 4294967296;\n            };\n            const loadValue = (addr) => {\n              const f = this.mem.getFloat64(addr, true);\n              if (f === 0) {\n                return void 0;\n              }\n              if (!isNaN(f)) {\n                return f;\n              }\n              const id = this.mem.getUint32(addr, true);\n              return this._values[id];\n            };\n            const storeValue = (addr, v) => {\n              const nanHead = 2146959360;\n              if (typeof v === "number" && v !== 0) {\n                if (isNaN(v)) {\n                  this.mem.setUint32(addr + 4, nanHead, true);\n                  this.mem.setUint32(addr, 0, true);\n                  return;\n                }\n                this.mem.setFloat64(addr, v, true);\n                return;\n              }\n              if (v === void 0) {\n                this.mem.setFloat64(addr, 0, true);\n                return;\n              }\n              let id = this._ids.get(v);\n              if (id === void 0) {\n                id = this._idPool.pop();\n                if (id === void 0) {\n                  id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n              }\n              this._goRefCounts[id]++;\n              let typeFlag = 0;\n              switch (typeof v) {\n                case "object":\n                  if (v !== null) {\n                    typeFlag = 1;\n                  }\n                  break;\n                case "string":\n                  typeFlag = 2;\n                  break;\n                case "symbol":\n                  typeFlag = 3;\n                  break;\n                case "function":\n                  typeFlag = 4;\n                  break;\n              }\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n              this.mem.setUint32(addr, id, true);\n            };\n            const loadSlice = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            const loadSliceOfValues = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              const a = new Array(len);\n              for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n              }\n              return a;\n            };\n            const loadString = (addr) => {\n              const saddr = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n              go: {\n                // Go\'s SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                // This changes the SP, thus we have to update the SP used by the imported function.\n                // func wasmExit(code int32)\n                "runtime.wasmExit": (sp) => {\n                  sp >>>= 0;\n                  const code = this.mem.getInt32(sp + 8, true);\n                  this.exited = true;\n                  delete this._inst;\n                  delete this._values;\n                  delete this._goRefCounts;\n                  delete this._ids;\n                  delete this._idPool;\n                  this.exit(code);\n                },\n                // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                "runtime.wasmWrite": (sp) => {\n                  sp >>>= 0;\n                  const fd = getInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                // func resetMemoryDataView()\n                "runtime.resetMemoryDataView": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                // func nanotime1() int64\n                "runtime.nanotime1": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                // func walltime() (sec int64, nsec int32)\n                "runtime.walltime": (sp) => {\n                  sp >>>= 0;\n                  const msec = (/* @__PURE__ */ new Date()).getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                // func scheduleTimeoutEvent(delay int64) int32\n                "runtime.scheduleTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(\n                    () => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn("scheduleTimeoutEvent: missed timeout event");\n                        this._resume();\n                      }\n                    },\n                    getInt64(sp + 8) + 1\n                    // setTimeout has been seen to fire up to 1 millisecond early\n                  ));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                // func clearTimeoutEvent(id int32)\n                "runtime.clearTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                // func getRandomData(r []byte)\n                "runtime.getRandomData": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                // func finalizeRef(v ref)\n                "syscall/js.finalizeRef": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                // func stringVal(value string) ref\n                "syscall/js.stringVal": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                // func valueGet(v ref, p string) ref\n                "syscall/js.valueGet": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                // func valueSet(v ref, p string, x ref)\n                "syscall/js.valueSet": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                // func valueDelete(v ref, p string)\n                "syscall/js.valueDelete": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                // func valueIndex(v ref, i int) ref\n                "syscall/js.valueIndex": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                // valueSetIndex(v ref, i int, x ref)\n                "syscall/js.valueSetIndex": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                // func valueCall(v ref, m string, args []ref) (ref, bool)\n                "syscall/js.valueCall": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                // func valueInvoke(v ref, args []ref) (ref, bool)\n                "syscall/js.valueInvoke": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                // func valueNew(v ref, args []ref) (ref, bool)\n                "syscall/js.valueNew": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                // func valueLength(v ref) int\n                "syscall/js.valueLength": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                // valuePrepareString(v ref) (ref, int)\n                "syscall/js.valuePrepareString": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                // valueLoadString(v ref, b []byte)\n                "syscall/js.valueLoadString": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                // func valueInstanceOf(v ref, t ref) bool\n                "syscall/js.valueInstanceOf": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                "syscall/js.copyBytesToGo": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                "syscall/js.copyBytesToJS": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "debug": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          run(instance) {\n            return __async(this, null, function* () {\n              if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error("Go.run: WebAssembly.Instance expected");\n              }\n              this._inst = instance;\n              this.mem = new DataView(this._inst.exports.mem.buffer);\n              this._values = [\n                // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n              ];\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\n              this._ids = /* @__PURE__ */ new Map([\n                // mapping from JS values to reference ids\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6]\n              ]);\n              this._idPool = [];\n              this.exited = false;\n              let offset = 4096;\n              const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + "\\0");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                  offset += 8 - offset % 8;\n                }\n                return ptr;\n              };\n              const argc = this.argv.length;\n              const argvPtrs = [];\n              this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n              });\n              argvPtrs.push(0);\n              const keys = Object.keys(this.env).sort();\n              keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n              });\n              argvPtrs.push(0);\n              const argv = offset;\n              argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n              });\n              const wasmMinDataAddr = 4096 + 8192;\n              if (offset >= wasmMinDataAddr) {\n                throw new Error("total length of command line and environment variables exceeds limit");\n              }\n              this._inst.exports.run(argc, argv);\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n              yield this._exitPromise;\n            });\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error("Go program has already exited");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = "";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split("\\n");\n            if (parts.length > 1)\n              console.log(parts.slice(0, -1).join("\\n"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error("Bad write");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin)\n              resumeStdin();\n          }\n          return go;\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error("Bad read");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = ["", `--service=${"0.19.12"}`];\n        tryToInstantiateModule(wasm, go).then(\n          (instance) => {\n            postMessage(null);\n            go.run(instance);\n          },\n          (error) => {\n            postMessage(error);\n          }\n        );\n        return go;\n      };\n      function tryToInstantiateModule(wasm, go) {\n        return __async(this, null, function* () {\n          if (wasm instanceof WebAssembly.Module) {\n            return WebAssembly.instantiate(wasm, go.importObject);\n          }\n          const res = yield fetch(wasm);\n          if (!res.ok)\n            throw new Error(`Failed to download ${JSON.stringify(wasm)}`);\n          if ("instantiateStreaming" in WebAssembly && /^application\\/wasm($|;)/i.test(res.headers.get("Content-Type") || "")) {\n            const result2 = yield WebAssembly.instantiateStreaming(res, go.importObject);\n            return result2.instance;\n          }\n          const bytes = yield res.arrayBuffer();\n          const result = yield WebAssembly.instantiate(bytes, go.importObject);\n          return result.instance;\n        });\n      }\n      return (m) => onmessage(m);\n    })(postMessage)'],{type:"text/javascript"});worker=new Worker(URL.createObjectURL(blob))}else{let go,onmessage=(postMessage=>{var __async=(__this,__arguments,generator)=>new Promise((resolve,reject)=>{var fulfilled=value=>{try{step(generator.next(value))}catch(e){reject(e)}},rejected=value=>{try{step(generator.throw(value))}catch(e){reject(e)}},step=x=>x.done?resolve(x.value):Promise.resolve(x.value).then(fulfilled,rejected);step((generator=generator.apply(__this,__arguments)).next())});let onmessage,globalThis={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))k in globalThis||Object.defineProperty(globalThis,k,{get:()=>self[k]});return(()=>{const enosys=()=>{const err=new Error("not implemented");return err.code="ENOSYS",err};if(!globalThis.fs){let outputBuf="";globalThis.fs={constants:{O_WRONLY:-1,O_RDWR:-1,O_CREAT:-1,O_TRUNC:-1,O_APPEND:-1,O_EXCL:-1},writeSync(fd,buf){outputBuf+=decoder.decode(buf);const nl=outputBuf.lastIndexOf("\n");return-1!=nl&&(console.log(outputBuf.substring(0,nl)),outputBuf=outputBuf.substring(nl+1)),buf.length},write(fd,buf,offset,length,position,callback){if(0!==offset||length!==buf.length||null!==position)return void callback(enosys());callback(null,this.writeSync(fd,buf))},chmod(path,mode,callback){callback(enosys())},chown(path,uid,gid,callback){callback(enosys())},close(fd,callback){callback(enosys())},fchmod(fd,mode,callback){callback(enosys())},fchown(fd,uid,gid,callback){callback(enosys())},fstat(fd,callback){callback(enosys())},fsync(fd,callback){callback(null)},ftruncate(fd,length,callback){callback(enosys())},lchown(path,uid,gid,callback){callback(enosys())},link(path,link,callback){callback(enosys())},lstat(path,callback){callback(enosys())},mkdir(path,perm,callback){callback(enosys())},open(path,flags,mode,callback){callback(enosys())},read(fd,buffer,offset,length,position,callback){callback(enosys())},readdir(path,callback){callback(enosys())},readlink(path,callback){callback(enosys())},rename(from,to,callback){callback(enosys())},rmdir(path,callback){callback(enosys())},stat(path,callback){callback(enosys())},symlink(path,link,callback){callback(enosys())},truncate(path,length,callback){callback(enosys())},unlink(path,callback){callback(enosys())},utimes(path,atime,mtime,callback){callback(enosys())}}}if(globalThis.process||(globalThis.process={getuid:()=>-1,getgid:()=>-1,geteuid:()=>-1,getegid:()=>-1,getgroups(){throw enosys()},pid:-1,ppid:-1,umask(){throw enosys()},cwd(){throw enosys()},chdir(){throw enosys()}}),!globalThis.crypto)throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");if(!globalThis.performance)throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");if(!globalThis.TextEncoder)throw new Error("globalThis.TextEncoder is not available, polyfill required");if(!globalThis.TextDecoder)throw new Error("globalThis.TextDecoder is not available, polyfill required");const encoder=new TextEncoder("utf-8"),decoder=new TextDecoder("utf-8");globalThis.Go=class{constructor(){this.argv=["js"],this.env={},this.exit=code=>{0!==code&&console.warn("exit code:",code)},this._exitPromise=new Promise(resolve=>{this._resolveExitPromise=resolve}),this._pendingEvent=null,this._scheduledTimeouts=new Map,this._nextCallbackTimeoutID=1;const setInt64=(addr,v)=>{this.mem.setUint32(addr+0,v,!0),this.mem.setUint32(addr+4,Math.floor(v/4294967296),!0)},getInt64=addr=>this.mem.getUint32(addr+0,!0)+4294967296*this.mem.getInt32(addr+4,!0),loadValue=addr=>{const f=this.mem.getFloat64(addr,!0);if(0===f)return;if(!isNaN(f))return f;const id=this.mem.getUint32(addr,!0);return this._values[id]},storeValue=(addr,v)=>{if("number"==typeof v&&0!==v)return isNaN(v)?(this.mem.setUint32(addr+4,2146959360,!0),void this.mem.setUint32(addr,0,!0)):void this.mem.setFloat64(addr,v,!0);if(void 0===v)return void this.mem.setFloat64(addr,0,!0);let id=this._ids.get(v);void 0===id&&(id=this._idPool.pop(),void 0===id&&(id=this._values.length),this._values[id]=v,this._goRefCounts[id]=0,this._ids.set(v,id)),this._goRefCounts[id]++;let typeFlag=0;switch(typeof v){case"object":null!==v&&(typeFlag=1);break;case"string":typeFlag=2;break;case"symbol":typeFlag=3;break;case"function":typeFlag=4}this.mem.setUint32(addr+4,2146959360|typeFlag,!0),this.mem.setUint32(addr,id,!0)},loadSlice=addr=>{const array=getInt64(addr+0),len=getInt64(addr+8);return new Uint8Array(this._inst.exports.mem.buffer,array,len)},loadSliceOfValues=addr=>{const array=getInt64(addr+0),len=getInt64(addr+8),a=new Array(len);for(let i=0;i<len;i++)a[i]=loadValue(array+8*i);return a},loadString=addr=>{const saddr=getInt64(addr+0),len=getInt64(addr+8);return decoder.decode(new DataView(this._inst.exports.mem.buffer,saddr,len))},timeOrigin=Date.now()-performance.now();this.importObject={go:{"runtime.wasmExit":sp=>{sp>>>=0;const code=this.mem.getInt32(sp+8,!0);this.exited=!0,delete this._inst,delete this._values,delete this._goRefCounts,delete this._ids,delete this._idPool,this.exit(code)},"runtime.wasmWrite":sp=>{const fd=getInt64((sp>>>=0)+8),p=getInt64(sp+16),n=this.mem.getInt32(sp+24,!0);globalThis.fs.writeSync(fd,new Uint8Array(this._inst.exports.mem.buffer,p,n))},"runtime.resetMemoryDataView":sp=>{this.mem=new DataView(this._inst.exports.mem.buffer)},"runtime.nanotime1":sp=>{setInt64((sp>>>=0)+8,1e6*(timeOrigin+performance.now()))},"runtime.walltime":sp=>{sp>>>=0;const msec=(new Date).getTime();setInt64(sp+8,msec/1e3),this.mem.setInt32(sp+16,msec%1e3*1e6,!0)},"runtime.scheduleTimeoutEvent":sp=>{sp>>>=0;const id=this._nextCallbackTimeoutID;this._nextCallbackTimeoutID++,this._scheduledTimeouts.set(id,setTimeout(()=>{for(this._resume();this._scheduledTimeouts.has(id);)console.warn("scheduleTimeoutEvent: missed timeout event"),this._resume()},getInt64(sp+8)+1)),this.mem.setInt32(sp+16,id,!0)},"runtime.clearTimeoutEvent":sp=>{sp>>>=0;const id=this.mem.getInt32(sp+8,!0);clearTimeout(this._scheduledTimeouts.get(id)),this._scheduledTimeouts.delete(id)},"runtime.getRandomData":sp=>{sp>>>=0,crypto.getRandomValues(loadSlice(sp+8))},"syscall/js.finalizeRef":sp=>{sp>>>=0;const id=this.mem.getUint32(sp+8,!0);if(this._goRefCounts[id]--,0===this._goRefCounts[id]){const v=this._values[id];this._values[id]=null,this._ids.delete(v),this._idPool.push(id)}},"syscall/js.stringVal":sp=>{storeValue((sp>>>=0)+24,loadString(sp+8))},"syscall/js.valueGet":sp=>{sp>>>=0;const result=Reflect.get(loadValue(sp+8),loadString(sp+16));sp=this._inst.exports.getsp()>>>0,storeValue(sp+32,result)},"syscall/js.valueSet":sp=>{sp>>>=0,Reflect.set(loadValue(sp+8),loadString(sp+16),loadValue(sp+32))},"syscall/js.valueDelete":sp=>{sp>>>=0,Reflect.deleteProperty(loadValue(sp+8),loadString(sp+16))},"syscall/js.valueIndex":sp=>{storeValue((sp>>>=0)+24,Reflect.get(loadValue(sp+8),getInt64(sp+16)))},"syscall/js.valueSetIndex":sp=>{sp>>>=0,Reflect.set(loadValue(sp+8),getInt64(sp+16),loadValue(sp+24))},"syscall/js.valueCall":sp=>{sp>>>=0;try{const v=loadValue(sp+8),m=Reflect.get(v,loadString(sp+16)),args=loadSliceOfValues(sp+32),result=Reflect.apply(m,v,args);sp=this._inst.exports.getsp()>>>0,storeValue(sp+56,result),this.mem.setUint8(sp+64,1)}catch(err){sp=this._inst.exports.getsp()>>>0,storeValue(sp+56,err),this.mem.setUint8(sp+64,0)}},"syscall/js.valueInvoke":sp=>{sp>>>=0;try{const v=loadValue(sp+8),args=loadSliceOfValues(sp+16),result=Reflect.apply(v,void 0,args);sp=this._inst.exports.getsp()>>>0,storeValue(sp+40,result),this.mem.setUint8(sp+48,1)}catch(err){sp=this._inst.exports.getsp()>>>0,storeValue(sp+40,err),this.mem.setUint8(sp+48,0)}},"syscall/js.valueNew":sp=>{sp>>>=0;try{const v=loadValue(sp+8),args=loadSliceOfValues(sp+16),result=Reflect.construct(v,args);sp=this._inst.exports.getsp()>>>0,storeValue(sp+40,result),this.mem.setUint8(sp+48,1)}catch(err){sp=this._inst.exports.getsp()>>>0,storeValue(sp+40,err),this.mem.setUint8(sp+48,0)}},"syscall/js.valueLength":sp=>{setInt64((sp>>>=0)+16,parseInt(loadValue(sp+8).length))},"syscall/js.valuePrepareString":sp=>{sp>>>=0;const str=encoder.encode(String(loadValue(sp+8)));storeValue(sp+16,str),setInt64(sp+24,str.length)},"syscall/js.valueLoadString":sp=>{const str=loadValue((sp>>>=0)+8);loadSlice(sp+16).set(str)},"syscall/js.valueInstanceOf":sp=>{sp>>>=0,this.mem.setUint8(sp+24,loadValue(sp+8)instanceof loadValue(sp+16)?1:0)},"syscall/js.copyBytesToGo":sp=>{const dst=loadSlice((sp>>>=0)+8),src=loadValue(sp+32);if(!(src instanceof Uint8Array||src instanceof Uint8ClampedArray))return void this.mem.setUint8(sp+48,0);const toCopy=src.subarray(0,dst.length);dst.set(toCopy),setInt64(sp+40,toCopy.length),this.mem.setUint8(sp+48,1)},"syscall/js.copyBytesToJS":sp=>{const dst=loadValue((sp>>>=0)+8),src=loadSlice(sp+16);if(!(dst instanceof Uint8Array||dst instanceof Uint8ClampedArray))return void this.mem.setUint8(sp+48,0);const toCopy=src.subarray(0,dst.length);dst.set(toCopy),setInt64(sp+40,toCopy.length),this.mem.setUint8(sp+48,1)},debug:value=>{console.log(value)}}}}run(instance){return __async(this,null,function*(){if(!(instance instanceof WebAssembly.Instance))throw new Error("Go.run: WebAssembly.Instance expected");this._inst=instance,this.mem=new DataView(this._inst.exports.mem.buffer),this._values=[NaN,0,null,!0,!1,globalThis,this],this._goRefCounts=new Array(this._values.length).fill(1/0),this._ids=new Map([[0,1],[null,2],[!0,3],[!1,4],[globalThis,5],[this,6]]),this._idPool=[],this.exited=!1;let offset=4096;const strPtr=str=>{const ptr=offset,bytes=encoder.encode(str+"\0");return new Uint8Array(this.mem.buffer,offset,bytes.length).set(bytes),offset+=bytes.length,offset%8!=0&&(offset+=8-offset%8),ptr},argc=this.argv.length,argvPtrs=[];this.argv.forEach(arg=>{argvPtrs.push(strPtr(arg))}),argvPtrs.push(0);Object.keys(this.env).sort().forEach(key=>{argvPtrs.push(strPtr(`${key}=${this.env[key]}`))}),argvPtrs.push(0);const argv=offset;argvPtrs.forEach(ptr=>{this.mem.setUint32(offset,ptr,!0),this.mem.setUint32(offset+4,0,!0),offset+=8});if(offset>=12288)throw new Error("total length of command line and environment variables exceeds limit");this._inst.exports.run(argc,argv),this.exited&&this._resolveExitPromise(),yield this._exitPromise})}_resume(){if(this.exited)throw new Error("Go program has already exited");this._inst.exports.resume(),this.exited&&this._resolveExitPromise()}_makeFuncWrapper(id){const go=this;return function(){const event={id,this:this,args:arguments};return go._pendingEvent=event,go._resume(),event.result}}}})(),onmessage=({data:wasm})=>{let decoder=new TextDecoder,fs=globalThis.fs,stderr="";fs.writeSync=(fd,buffer)=>{if(1===fd)postMessage(buffer);else{if(2!==fd)throw new Error("Bad write");{stderr+=decoder.decode(buffer);let parts=stderr.split("\n");parts.length>1&&console.log(parts.slice(0,-1).join("\n")),stderr=parts[parts.length-1]}}return buffer.length};let resumeStdin,stdin=[],stdinPos=0;onmessage=({data})=>(data.length>0&&(stdin.push(data),resumeStdin&&resumeStdin()),go),fs.read=(fd,buffer,offset,length,position,callback)=>{if(0!==fd||0!==offset||length!==buffer.length||null!==position)throw new Error("Bad read");if(0===stdin.length)return void(resumeStdin=()=>fs.read(fd,buffer,offset,length,position,callback));let first=stdin[0],count=Math.max(0,Math.min(length,first.length-stdinPos));buffer.set(first.subarray(stdinPos,stdinPos+count),offset),stdinPos+=count,stdinPos===first.length&&(stdin.shift(),stdinPos=0),callback(null,count)};let go=new globalThis.Go;return go.argv=["","--service=0.19.12"],function tryToInstantiateModule(wasm,go){return __async(this,null,function*(){if(wasm instanceof WebAssembly.Module)return WebAssembly.instantiate(wasm,go.importObject);const res=yield fetch(wasm);if(!res.ok)throw new Error(`Failed to download ${JSON.stringify(wasm)}`);if("instantiateStreaming"in WebAssembly&&/^application\/wasm($|;)/i.test(res.headers.get("Content-Type")||"")){return(yield WebAssembly.instantiateStreaming(res,go.importObject)).instance}const bytes=yield res.arrayBuffer();return(yield WebAssembly.instantiate(bytes,go.importObject)).instance})}(wasm,go).then(instance=>{postMessage(null),go.run(instance)},error=>{postMessage(error)}),go},m=>onmessage(m)})(data=>worker.onmessage({data}));worker={onmessage:null,postMessage:data=>setTimeout(()=>go=onmessage({data})),terminate(){if(go)for(let timeout of go._scheduledTimeouts.values())clearTimeout(timeout)}}}const firstMessagePromise=new Promise((resolve,reject)=>{firstMessageResolve=resolve,firstMessageReject=reject});worker.onmessage=({data:error})=>{worker.onmessage=({data})=>readFromStdout(data),error?firstMessageReject(error):firstMessageResolve()},worker.postMessage(wasmModule||new URL(wasmURL,location.href).toString());let{readFromStdout,service}=createChannel({writeToStdin(bytes){worker.postMessage(bytes)},isSync:!1,hasFS:!1,esbuild:browser_exports});yield firstMessagePromise,stopService=()=>{worker.terminate(),initializePromise=void 0,stopService=void 0,longLivedService=void 0},longLivedService={build:options=>new Promise((resolve,reject)=>service.buildOrContext({callName:"build",refs:null,options,isTTY:!1,defaultWD:"/",callback:(err,res)=>err?reject(err):resolve(res)})),context:options=>new Promise((resolve,reject)=>service.buildOrContext({callName:"context",refs:null,options,isTTY:!1,defaultWD:"/",callback:(err,res)=>err?reject(err):resolve(res)})),transform:(input,options)=>new Promise((resolve,reject)=>service.transform({callName:"transform",refs:null,input,options:options||{},isTTY:!1,fs:{readFile(_,callback){callback(new Error("Internal error"),null)},writeFile(_,callback){callback(null)}},callback:(err,res)=>err?reject(err):resolve(res)})),formatMessages:(messages,options)=>new Promise((resolve,reject)=>service.formatMessages({callName:"formatMessages",refs:null,messages,options,callback:(err,res)=>err?reject(err):resolve(res)})),analyzeMetafile:(metafile,options)=>new Promise((resolve,reject)=>service.analyzeMetafile({callName:"analyzeMetafile",refs:null,metafile:"string"==typeof metafile?metafile:JSON.stringify(metafile),options,callback:(err,res)=>err?reject(err):resolve(res)}))}}),browser_default=browser_exports})(module)}}]);