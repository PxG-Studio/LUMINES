"use strict";(self.webpackChunklumines_wissil=self.webpackChunklumines_wissil||[]).push([[2495],{"./node_modules/@webcontainer/api/dist/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{PreviewMessageType:()=>PreviewMessageType,WebContainer:()=>WebContainer,auth:()=>dist_auth,configureAPIKey:()=>configureAPIKey,isPreviewMessage:()=>isPreviewMessage,reloadPreview:()=>reloadPreview});class TypedEventTarget{_bus=new EventTarget;listen(listener){function wrappedListener(event){listener(event.data)}return this._bus.addEventListener("message",wrappedListener),()=>this._bus.removeEventListener("message",wrappedListener)}fireEvent(data){this._bus.dispatchEvent(new MessageEvent("message",{data}))}}const IGNORED_ERROR=new Error;IGNORED_ERROR.stack="";const accessTokenChangedListeners=new TypedEventTarget;class Tokens{origin;refresh;access;expires;_revoked=new AbortController;constructor(origin,refresh,access,expires){this.origin=origin,this.refresh=refresh,this.access=access,this.expires=expires}async activate(onFailedRefresh){if(this._revoked.signal.aborted)throw new Error("Token revoked");return!(this.expires<Date.now()&&!await this._fetchNewAccessToken())&&(this._sync(),this._startRefreshTokensLoop(onFailedRefresh),!0)}async revoke(clientId,ignoreRevokeError){this._revoked.abort();try{if(!(await fetch(`${this.origin}/oauth/revoke`,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({token:this.refresh,token_type_hint:"refresh_token",client_id:clientId}),mode:"cors"})).ok)throw new Error("Failed to logout")}catch(error){if(!ignoreRevokeError)throw error}clearTokensInStorage()}static fromStorage(){const savedTokens=function readTokensFromStorage(){const serializedTokens=localStorage.getItem("__wc_api_tokens__");if(!serializedTokens)return null;try{return JSON.parse(serializedTokens)}catch{return null}}();return savedTokens?new Tokens(savedTokens.origin,savedTokens.refresh,savedTokens.access,savedTokens.expires):null}static async fromAuthCode({editorOrigin,clientId,codeVerifier,authCode,redirectUri}){const response=await fetch(`${editorOrigin}/oauth/token`,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:clientId,code:authCode,code_verifier:codeVerifier,grant_type:"authorization_code",redirect_uri:redirectUri}),mode:"cors"});if(!response.ok)throw new Error(`Failed to fetch token: ${response.status}`);const tokenResponse=await response.json();assertTokenResponse(tokenResponse);const{access_token:access,refresh_token:refresh}=tokenResponse,expires=getExpiresFromTokenResponse(tokenResponse);return new Tokens(editorOrigin,refresh,access,expires)}async _fetchNewAccessToken(){try{const response=await fetch(`${this.origin}/oauth/token`,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({grant_type:"refresh_token",refresh_token:this.refresh}),mode:"cors",signal:this._revoked.signal});if(!response.ok)throw IGNORED_ERROR;const tokenResponse=await response.json();assertTokenResponse(tokenResponse);const{access_token:access,refresh_token:refresh}=tokenResponse,expires=getExpiresFromTokenResponse(tokenResponse);return this.access=access,this.expires=expires,this.refresh=refresh,!0}catch{return clearTokensInStorage(),!1}}_sync(){!function persistTokensInStorage(tokens){localStorage.setItem("__wc_api_tokens__",JSON.stringify(tokens))}(this),function fireAccessTokenChanged(accessToken){accessTokenChangedListeners.fireEvent(accessToken)}(this.access)}async _startRefreshTokensLoop(onFailedRefresh){for(;;){const expiresIn=this.expires-Date.now()-1e3;if(await wait(Math.max(expiresIn,1e3)),this._revoked.signal.aborted)return;if(!this._fetchNewAccessToken())return void onFailedRefresh();this._sync()}}}function clearTokensInStorage(){localStorage.removeItem("__wc_api_tokens__")}function getExpiresFromTokenResponse({created_at,expires_in}){return 1e3*(created_at+expires_in)}function assertTokenResponse(token){if("object"!=typeof token||!token)throw new Error("Invalid Token Response");if("string"!=typeof token.access_token||"string"!=typeof token.refresh_token||"number"!=typeof token.created_at||"number"!=typeof token.expires_in)throw new Error("Invalid Token Response")}function wait(ms){return new Promise(resolve=>setTimeout(resolve,ms))}const params={};let editorOrigin=null;const iframeSettings={get editorOrigin(){return null==editorOrigin&&(editorOrigin=new URL(globalThis.WEBCONTAINER_API_IFRAME_URL??"https://stackblitz.com").origin),editorOrigin},set editorOrigin(newOrigin){editorOrigin=new URL(newOrigin).origin},setQueryParam(key,value){params[key]=value},get url(){const url=new URL(this.editorOrigin);url.pathname="/headless";for(const param in params)url.searchParams.set(param,params[param]);return url.searchParams.set("version","1.6.1"),url}};function nextFourChars(byte1,byte2,byte3){return[byte1>>2,(3&byte1)<<4|byte2>>4,15&byte2|(192&byte3)>>2,63&byte3].map(unreservedCharacters).join("")}function unreservedCharacters(code){let offset;return offset=code<26?code+65:code<52?code-26+97:code<62?code-52+48:62===code?30:45,String.fromCharCode(offset)}var console=__webpack_require__("./node_modules/console-browserify/index.js");const authState={initialized:!1,bootCalled:!1,authComplete:function resettablePromise(){let resolve,promise;function reset(){promise=new Promise(_resolve=>resolve=_resolve)}return reset(),{get promise(){return promise},resolve:value=>resolve(value),reset}}(),clientId:"",oauthScope:"",broadcastChannel:null,get editorOrigin(){return iframeSettings.editorOrigin},tokens:null},authFailedListeners=new TypedEventTarget,loggedOutListeners=new TypedEventTarget;function broadcastMessage(message){authState.broadcastChannel&&(authState.broadcastChannel.postMessage(message),"true"===localStorage.getItem("__wc_api_popup__")&&"auth-logout"!==message.type&&(localStorage.removeItem("__wc_api_popup__"),setTimeout(()=>{window.close()})))}const auth={init({editorOrigin,clientId,scope}){if(authState.initialized)throw new Error("Init should only be called once");if(authState.bootCalled)throw new Error("`auth.init` should always be called before `WebContainer.boot`");if(authState.initialized=!0,authState.tokens=Tokens.fromStorage(),authState.clientId=clientId,authState.oauthScope=scope,authState.broadcastChannel=new BroadcastChannel("__wc_api_bc__"),iframeSettings.setQueryParam("client_id",clientId),editorOrigin&&(iframeSettings.editorOrigin=new URL(editorOrigin).origin),loggedOutListeners.listen(()=>authState.authComplete.reset()),authState.broadcastChannel.addEventListener("message",async function onChannelMessage(event){const typedEvent=event.data;if("auth-complete"===typedEvent.type)return authState.tokens=Tokens.fromStorage(),await authState.tokens.activate(onFailedTokenRefresh),void authState.authComplete.resolve();if("auth-failed"===typedEvent.type)return void authFailedListeners.fireEvent(typedEvent);if("auth-logout"===typedEvent.type)return void loggedOutListeners.fireEvent()}),authState.tokens){const tokens=authState.tokens;if(tokens.origin===authState.editorOrigin)return(async()=>{if(await tokens.activate(onFailedTokenRefresh))authState.authComplete.resolve();else{if(authState.tokens!==tokens)return;loggedOutListeners.fireEvent()}})(),{status:"authorized"};clearTokensInStorage(),authState.tokens=null}const locationURL=new URL(window.location.href),{searchParams}=locationURL,updateURL=()=>window.history.replaceState({},document.title,locationURL);if(searchParams.has("error")){const error=searchParams.get("error"),description=searchParams.get("error_description");return searchParams.delete("error"),searchParams.delete("error_description"),updateURL(),broadcastMessage({type:"auth-failed",error,description}),{status:"auth-failed",error,description}}if(searchParams.has("code")){const authCode=searchParams.get("code"),editorOrigin=authState.editorOrigin;searchParams.delete("code"),updateURL();const codeVerifier=localStorage.getItem("__wc_api_verifier__");return codeVerifier?(localStorage.removeItem("__wc_api_verifier__"),Tokens.fromAuthCode({editorOrigin,clientId:authState.clientId,authCode,codeVerifier,redirectUri:defaultRedirectUri()}).then(async tokens=>{authState.tokens=tokens,assertAuthTokens(authState.tokens);if(!await authState.tokens.activate(onFailedTokenRefresh))throw new Error;authState.authComplete.resolve(),broadcastMessage({type:"auth-complete"})}).catch(error=>{console.error(error),loggedOutListeners.fireEvent(),broadcastMessage({type:"auth-logout"})}),{status:"authorized"}):{status:"need-auth"}}return{status:"need-auth"}},async startAuthFlow({popup}={}){if(!authState.initialized)throw new Error("auth.init must be called first");if(popup){localStorage.setItem("__wc_api_popup__","true");const height=500,width=620,left=window.screenLeft+(window.outerWidth-width)/2,top=window.screenTop+(window.outerHeight-height)/2;window.open(await generateOAuthRequest(),"_blank",`popup,width=${width},height=${height},left=${left},top=${top}`)}else window.location.href=await generateOAuthRequest()},async logout({ignoreRevokeError}={}){await(authState.tokens?.revoke(authState.clientId,ignoreRevokeError??!1)),loggedOutListeners.fireEvent(),broadcastMessage({type:"auth-logout"})},loggedIn:()=>authState.authComplete.promise,on(event,listener){switch(event){case"auth-failed":return authFailedListeners.listen(listener);case"logged-out":return loggedOutListeners.listen(listener);default:throw new Error(`Unsupported event type '${event}'.`)}}};function onFailedTokenRefresh(){loggedOutListeners.fireEvent(),broadcastMessage({type:"auth-logout"})}function defaultRedirectUri(){return window.location.href}async function generateOAuthRequest(){const codeVerifier=function newCodeVerifier(){const random=new Uint8Array(96);crypto.getRandomValues(random);let codeVerifier="";for(let i=0;i<32;++i)codeVerifier+=nextFourChars(random[3*i+0],random[3*i+1],random[3*i+2]);return codeVerifier}();localStorage.setItem("__wc_api_verifier__",codeVerifier);const codeChallenge=await async function S256(input){const ascii=(new TextEncoder).encode(input),sha256=new Uint8Array(await crypto.subtle.digest("SHA-256",ascii));return btoa(sha256.reduce((binary,byte)=>binary+String.fromCodePoint(byte),"")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}(codeVerifier),url=new URL("/oauth/authorize",authState.editorOrigin),{searchParams}=url;return searchParams.append("response_type","code"),searchParams.append("client_id",authState.clientId),searchParams.append("redirect_uri",defaultRedirectUri()),searchParams.append("scope",authState.oauthScope),searchParams.append("code_challenge",codeChallenge),searchParams.append("code_challenge_method","S256"),url.toString()}function assertAuthTokens(tokens){if(!tokens)throw new Error("Oops! Tokens is not defined when it always should be.")}var PreviewMessageType;!function(PreviewMessageType){PreviewMessageType.UncaughtException="PREVIEW_UNCAUGHT_EXCEPTION",PreviewMessageType.UnhandledRejection="PREVIEW_UNHANDLED_REJECTION",PreviewMessageType.ConsoleError="PREVIEW_CONSOLE_ERROR"}(PreviewMessageType||(PreviewMessageType={}));var __defProp=Object.defineProperty,comlink_exports={};((target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})})(comlink_exports,{createEndpoint:()=>createEndpoint,expose:()=>expose,proxy:()=>proxy,proxyMarker:()=>proxyMarker,releaseProxy:()=>releaseProxy,transfer:()=>transfer,transferHandlers:()=>transferHandlers,windowEndpoint:()=>windowEndpoint,wrap:()=>wrap});var proxyMarker=Symbol("Comlink.proxy"),createEndpoint=Symbol("Comlink.endpoint"),releaseProxy=Symbol("Comlink.releaseProxy"),throwMarker=Symbol("Comlink.thrown"),isObject=val=>"object"==typeof val&&null!==val||"function"==typeof val,transferHandlers=new Map([["proxy",{canHandle:val=>isObject(val)&&val[proxyMarker],serialize(obj){const{port1,port2}=new MessageChannel;return expose(obj,port1),[port2,[port2]]},deserialize:port=>(port.start(),wrap(port))}],["throw",{canHandle:value=>isObject(value)&&throwMarker in value,serialize({value}){let serialized;return serialized=value instanceof Error?{isError:!0,value:{message:value.message,name:value.name,stack:value.stack}}:{isError:!1,value},[serialized,[]]},deserialize(serialized){if(serialized.isError)throw Object.assign(new Error(serialized.value.message),serialized.value);throw serialized.value}}]]);function expose(obj,ep=self){ep.addEventListener("message",function callback(ev){if(!ev||!ev.data)return;const{id,type,path}=Object.assign({path:[]},ev.data),argumentList=(ev.data.argumentList||[]).map(fromWireValue);let returnValue;try{const parent=path.slice(0,-1).reduce((obj2,prop)=>obj2[prop],obj),rawValue=path.reduce((obj2,prop)=>obj2[prop],obj);switch(type){case 0:returnValue=rawValue;break;case 1:parent[path.slice(-1)[0]]=fromWireValue(ev.data.value),returnValue=!0;break;case 2:returnValue=rawValue.apply(parent,argumentList);break;case 3:returnValue=proxy(new rawValue(...argumentList));break;case 4:{const{port1,port2}=new MessageChannel;expose(obj,port2),returnValue=transfer(port1,[port1])}break;case 5:returnValue=void 0}}catch(value){returnValue={value,[throwMarker]:0}}Promise.resolve(returnValue).catch(value=>({value,[throwMarker]:0})).then(returnValue2=>{const[wireValue,transferables]=toWireValue(returnValue2);ep.postMessage(Object.assign(Object.assign({},wireValue),{id}),transferables),5===type&&(ep.removeEventListener("message",callback),closeEndPoint(ep))})}),ep.start&&ep.start()}function closeEndPoint(endpoint){(function isMessagePort(endpoint){return"MessagePort"===endpoint.constructor.name})(endpoint)&&endpoint.close()}function wrap(ep,target){return createProxy(ep,[],target)}function throwIfProxyReleased(isReleased){if(isReleased)throw new Error("Proxy has been released and is not useable")}function createProxy(ep,path=[],target=function(){}){let isProxyReleased=!1;const proxy2=new Proxy(target,{get(_target,prop){if(throwIfProxyReleased(isProxyReleased),prop===releaseProxy)return()=>requestResponseMessage(ep,{type:5,path:path.map(p=>p.toString())}).then(()=>{closeEndPoint(ep),isProxyReleased=!0});if("then"===prop){if(0===path.length)return{then:()=>proxy2};const r=requestResponseMessage(ep,{type:0,path:path.map(p=>p.toString())}).then(fromWireValue);return r.then.bind(r)}return createProxy(ep,[...path,prop])},set(_target,prop,rawValue){throwIfProxyReleased(isProxyReleased);const[value,transferables]=toWireValue(rawValue);return requestResponseMessage(ep,{type:1,path:[...path,prop].map(p=>p.toString()),value},transferables).then(fromWireValue)},apply(_target,_thisArg,rawArgumentList){throwIfProxyReleased(isProxyReleased);const last=path[path.length-1];if(last===createEndpoint)return requestResponseMessage(ep,{type:4}).then(fromWireValue);if("bind"===last)return createProxy(ep,path.slice(0,-1));const[argumentList,transferables]=processArguments(rawArgumentList);return requestResponseMessage(ep,{type:2,path:path.map(p=>p.toString()),argumentList},transferables).then(fromWireValue)},construct(_target,rawArgumentList){throwIfProxyReleased(isProxyReleased);const[argumentList,transferables]=processArguments(rawArgumentList);return requestResponseMessage(ep,{type:3,path:path.map(p=>p.toString()),argumentList},transferables).then(fromWireValue)}});return proxy2}function processArguments(argumentList){const processed=argumentList.map(toWireValue);return[processed.map(v=>v[0]),(arr=processed.map(v=>v[1]),Array.prototype.concat.apply([],arr))];var arr}var transferCache=new WeakMap;function transfer(obj,transfers){return transferCache.set(obj,transfers),obj}function proxy(obj){return Object.assign(obj,{[proxyMarker]:!0})}function windowEndpoint(w,context=self,targetOrigin="*"){return{postMessage:(msg,transferables)=>w.postMessage(msg,targetOrigin,transferables),addEventListener:context.addEventListener.bind(context),removeEventListener:context.removeEventListener.bind(context)}}function toWireValue(value){for(const[name,handler]of transferHandlers)if(handler.canHandle(value)){const[serializedValue,transferables]=handler.serialize(value);return[{type:3,name,value:serializedValue},transferables]}return[{type:0,value},transferCache.get(value)||[]]}function fromWireValue(value){switch(value.type){case 3:return transferHandlers.get(value.name).deserialize(value.value);case 0:return value.value}}function requestResponseMessage(ep,msg,transfers){return new Promise(resolve=>{const id=function generateUUID(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}();ep.addEventListener("message",function l(ev){ev.data&&ev.data.id&&ev.data.id===id&&(ep.removeEventListener("message",l),resolve(ev.data))}),ep.start&&ep.start(),ep.postMessage(Object.assign({id},msg),transfers)})}function reloadPreview(preview,hardRefreshTimeout=200){const{port1,port2}=new MessageChannel;let resolve;const promise=new Promise(_resolve=>{resolve=_resolve}),done=()=>{resolve(),port2.close()},timeout=setTimeout(()=>{const iframeSrc=preview.src;preview.src=iframeSrc,done()},hardRefreshTimeout);return port2.addEventListener("message",event=>{const data=event.data;null!=data&&"object"==typeof data&&"LOCALSERVICE_WINDOW_RELOADED"===data.type&&(clearTimeout(timeout),done())}),preview.contentWindow?.postMessage({type:"LOCALSERVICE_RELOAD_WINDOW",callback:port1},"*",[port1]),promise}const PREVIEW_MESSAGE_TYPES=[PreviewMessageType.ConsoleError,PreviewMessageType.UncaughtException,PreviewMessageType.UnhandledRejection];function isPreviewMessage(data){return null!=data&&"object"==typeof data&&!(!("type"in data)||!PREVIEW_MESSAGE_TYPES.includes(data.type))}function nullPrototype(source){const prototype=Object.create(null);return source?Object.assign(prototype,source):prototype}const binaryDecoder=new TextDecoder("latin1");function toInternalFileSystemTree(tree){const newTree={d:{}};for(const name of Object.keys(tree)){const entry=tree[name];if("file"in entry){if("symlink"in entry.file){newTree.d[name]={f:{l:entry.file.symlink}};continue}const contents=entry.file.contents,stringContents="string"==typeof contents?contents:binaryDecoder.decode(contents),binary="string"==typeof contents?{}:{b:!0};newTree.d[name]={f:{c:stringContents,...binary}};continue}const newEntry=toInternalFileSystemTree(entry.directory);newTree.d[name]=newEntry}return newTree}function toExternalFileSystemTree(tree){const newTree=nullPrototype();if("f"in tree)throw new Error("It is not possible to export a single file in the JSON format.");if("d"in tree)for(const name of Object.keys(tree.d)){const entry=tree.d[name];"d"in entry?newTree[name]=nullPrototype({directory:toExternalFileSystemTree(entry)}):"f"in entry&&("c"in entry.f?newTree[name]=nullPrototype({file:nullPrototype({contents:entry.f.b?fromBinaryString(entry.f.c):entry.f.c})}):"l"in entry.f&&(newTree[name]=nullPrototype({file:nullPrototype({symlink:entry.f.l})})))}return newTree}function fromBinaryString(s){const encoded=new Uint8Array(s.length);for(let i=0;i<s.length;i++)encoded[i]=s[i].charCodeAt(0);return encoded}var dist_console=__webpack_require__("./node_modules/console-browserify/index.js");const dist_auth=auth;let bootPromise=null,cachedServerPromise=null,cachedBootOptions={};const decoder=new TextDecoder,encoder=new TextEncoder;class WebContainer{_instance;_runtimeInfo;fs;static _instance=null;static _teardownPromise=null;_tornDown=!1;_unsubscribeFromTokenChangedListener=()=>{};constructor(_instance,fs,previewScript,_runtimeInfo){this._instance=_instance,this._runtimeInfo=_runtimeInfo,this.fs=new FileSystemAPIClient(fs),authState.initialized&&(this._unsubscribeFromTokenChangedListener=function addAccessTokenChangedListener(listener){return accessTokenChangedListeners.listen(listener)}(accessToken=>{this._instance.setCredentials({accessToken,editorOrigin:authState.editorOrigin})}),(async()=>{await authState.authComplete.promise,this._tornDown||(assertAuthTokens(authState.tokens),await this._instance.setCredentials({accessToken:authState.tokens.access,editorOrigin:authState.editorOrigin}))})().catch(error=>{dist_console.error(error)}))}async spawn(command,optionsOrArgs,options){let output,args=[];Array.isArray(optionsOrArgs)?args=optionsOrArgs:options=optionsOrArgs;let stdout,stderr,outputStream=new ReadableStream;if(!1!==options?.output){const result=function streamWithPush(){let controller=null;const stream=new ReadableStream({start(controller_){controller=controller_}});return{stream,push:item=>{null!=item?controller?.enqueue(item):(controller?.close(),controller=null)}}}();output=result.push,outputStream=result.stream}const wrappedOutput=proxyListener(binaryListener(output)),wrappedStdout=proxyListener(binaryListener(stdout)),wrappedStderr=proxyListener(binaryListener(stderr)),process=await this._instance.run({command,args,cwd:options?.cwd,env:options?.env,terminal:options?.terminal},wrappedStdout,wrappedStderr,wrappedOutput);return new WebContainerProcessImpl(process,outputStream,undefined,undefined)}async export(path,options){const serializeOptions={format:options?.format??"json",includes:options?.includes,excludes:options?.excludes,external:!0},result=await this._instance.serialize(path,serializeOptions);if("json"===serializeOptions.format){return toExternalFileSystemTree(JSON.parse(decoder.decode(result)))}return result}on(event,listener){if("preview-message"===event){const originalListener=listener;listener=message=>{isPreviewMessage(message)&&originalListener(message)}}const{listener:wrapped,subscribe}=function syncSubscription(listener){let stopped=!1,unsubscribe=()=>{};const wrapped=(...args)=>{stopped||listener(...args)};return{subscribe:promise=>(promise.then(unsubscribe_=>{unsubscribe=unsubscribe_,stopped&&unsubscribe()}),()=>{stopped=!0,unsubscribe()}),listener:wrapped}}(listener);return subscribe(this._instance.on(event,comlink_exports.proxy(wrapped)))}mount(snapshotOrTree,options){const payload=snapshotOrTree instanceof Uint8Array?snapshotOrTree:snapshotOrTree instanceof ArrayBuffer?new Uint8Array(snapshotOrTree):encoder.encode(JSON.stringify(toInternalFileSystemTree(snapshotOrTree)));return this._instance.loadFiles(comlink_exports.transfer(payload,[payload.buffer]),{mountPoints:options?.mountPoint})}setPreviewScript(scriptSrc,options){return this._instance.setPreviewScript(scriptSrc,options)}get path(){return this._runtimeInfo.path}get workdir(){return this._runtimeInfo.cwd}teardown(){if(this._tornDown)throw new Error("WebContainer already torn down");this._tornDown=!0,this._unsubscribeFromTokenChangedListener();WebContainer._teardownPromise=(async()=>{try{await this.fs._teardown(),await this._instance.teardown()}finally{this._instance[comlink_exports.releaseProxy](),WebContainer._instance===this&&(WebContainer._instance=null)}})()}static async boot(options={}){await this._teardownPromise,WebContainer._teardownPromise=null;const{workdirName}=options;if(window.crossOriginIsolated&&"none"===options.coep&&dist_console.warn("A Cross-Origin-Embedder-Policy header is required in cross origin isolated environments.\nSet the 'coep' option to 'require-corp'."),workdirName?.includes("/")||".."===workdirName||"."===workdirName)throw new Error("workdirName should be a valid folder name");for(authState.bootCalled=!0;bootPromise;)await bootPromise;if(WebContainer._instance)throw new Error("Only a single WebContainer instance can be booted");const instancePromise=async function unsynchronizedBoot(options){const{serverPromise}=function serverFactory(options){if(null!=cachedServerPromise)return options.coep!==cachedBootOptions.coep&&(dist_console.warn(`Attempting to boot WebContainer with 'coep: ${options.coep}'`),dist_console.warn(`First boot had 'coep: ${cachedBootOptions.coep}', new settings will not take effect!`)),{serverPromise:cachedServerPromise};options.coep&&iframeSettings.setQueryParam("coep",options.coep);options.experimentalNode&&iframeSettings.setQueryParam("experimental_node","1");const iframe=document.createElement("iframe");iframe.style.display="none",iframe.setAttribute("allow","cross-origin-isolated");const url=iframeSettings.url;iframe.src=url.toString();const{origin}=url;return cachedBootOptions={...options},cachedServerPromise=new Promise(resolve=>{const onMessage=event=>{if(event.origin!==origin)return;const{data}=event;"init"!==data.type?"warning"!==data.type||dist_console[data.level].call(dist_console,data.message):resolve(comlink_exports.wrap(event.ports[0]))};window.addEventListener("message",onMessage)}),document.body.insertBefore(iframe,null),{serverPromise:cachedServerPromise}}(options),server=await serverPromise,instance=await server.build({host:window.location.host,version:"1.6.1",workdirName:options.workdirName,forwardPreviewErrors:options.forwardPreviewErrors}),[fs,previewScript,runtimeInfo]=await Promise.all([instance.fs(),instance.previewScript(),instance.runtimeInfo()]);return new WebContainer(instance,fs,previewScript,runtimeInfo)}(options);bootPromise=instancePromise.catch(()=>{});try{const instance=await instancePromise;return WebContainer._instance=instance,instance}finally{bootPromise=null}}}function configureAPIKey(key){if(authState.bootCalled)throw new Error("`configureAPIKey` should always be called before `WebContainer.boot`");iframeSettings.setQueryParam("client_id",key)}class DirEntImpl{name;_type;constructor(name,_type){this.name=name,this._type=_type}isFile(){return 1===this._type}isDirectory(){return 2===this._type}}class FSWatcher{_apiClient;_path;_options;_listener;_wrappedListener;_watcher;_closed=!1;constructor(_apiClient,_path,_options,_listener){this._apiClient=_apiClient,this._path=_path,this._options=_options,this._listener=_listener,this._apiClient._watchers.add(this),this._wrappedListener=(event,filename)=>{this._listener&&!this._closed&&this._listener(event,filename)},this._apiClient._fs.watch(this._path,this._options,proxyListener(this._wrappedListener)).then(_watcher=>{if(this._watcher=_watcher,this._closed)return this._teardown()}).catch(dist_console.error)}async close(){this._closed||(this._closed=!0,this._apiClient._watchers.delete(this),await this._teardown())}async _teardown(){await(this._watcher?.close().finally(()=>{this._watcher?.[comlink_exports.releaseProxy]()}))}}class WebContainerProcessImpl{output;input;exit;_process;stdout;stderr;constructor(process,output,stdout,stderr){this.output=output,this._process=process,this.input=new WritableStream({write:data=>{this._getProcess()?.write(data).catch(()=>{})}}),this.exit=this._onExit(),this.stdout=stdout,this.stderr=stderr}kill(){this._process?.kill()}resize(dimensions){this._getProcess()?.resize(dimensions)}async _onExit(){try{return await this._process.onExit}finally{this._process?.[comlink_exports.releaseProxy](),this._process=null}}_getProcess(){return null==this._process&&dist_console.warn("This process already exited"),this._process}}class FileSystemAPIClient{_fs;_watchers=new Set([]);constructor(fs){this._fs=fs}rm(...args){return this._fs.rm(...args)}async readFile(path,encoding){return await this._fs.readFile(path,encoding)}async rename(oldPath,newPath){return await this._fs.rename(oldPath,newPath)}async writeFile(path,data,options){if(data instanceof Uint8Array){const buffer=data.buffer.slice(data.byteOffset,data.byteOffset+data.byteLength);data=comlink_exports.transfer(new Uint8Array(buffer),[buffer])}await this._fs.writeFile(path,data,options)}async readdir(path,options){const result=await this._fs.readdir(path,options);if(function isStringArray(list){return"string"==typeof list[0]}(result))return result;if(function isTypedArrayCollection(list){return list[0]instanceof Uint8Array}(result))return result;return result.map(entry=>new DirEntImpl(entry.name,entry["Symbol(type)"]))}async mkdir(path,options){return await this._fs.mkdir(path,options)}watch(path,options,listener){return"function"==typeof options&&(listener=options,options=null),new FSWatcher(this,path,options,listener)}async _teardown(){this._fs[comlink_exports.releaseProxy](),await Promise.all([...this._watchers].map(watcher=>watcher.close()))}}function binaryListener(listener){if(null!=listener)return data=>{data instanceof Uint8Array?listener(decoder.decode(data)):null==data&&listener(null)}}function proxyListener(listener){if(null!=listener)return comlink_exports.proxy(listener)}}}]);